{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cours de Terminale NSI Programme du cours Interfaces de programmation d'applications R\u00e9cursivit\u00e9 Programmation objet Modularit\u00e9 Listes cha\u00een\u00e9es Mise au point de programmes M\u00e9thode diviser pour r\u00e9gner Piles et files Arbres Arbres binaires de recherche Recherche textuelle Graphes Graphes pond\u00e9r\u00e9s Calculabilit\u00e9 et d\u00e9cidabilit\u00e9 Sujets et corrig\u00e9s des devoirs Devoirs maison Immeubles al\u00e9atoires Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici S\u00e9ismes Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Casse-briques Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Traitement d'une image Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Devoirs surveill\u00e9s 1 Sujet de la premi\u00e8re partie \u00e0 t\u00e9l\u00e9charger ici Sujet de la seconde partie \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici \u00c9preuves pratiques 01 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 02 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 16 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 17 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 18 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 19 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 20 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 23 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 26 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 29 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Logiciels \u00e0 installer Installation d'Anaconda La suite Anaconda , t\u00e9l\u00e9chargeable ici , contient l'\u00e9diteur de carnets Jupyter et l'\u00e9diteur de code Spyder .","title":"Accueil"},{"location":"#cours-de-terminale-nsi","text":"","title":"Cours de Terminale NSI"},{"location":"#programme-du-cours","text":"Interfaces de programmation d'applications R\u00e9cursivit\u00e9 Programmation objet Modularit\u00e9 Listes cha\u00een\u00e9es Mise au point de programmes M\u00e9thode diviser pour r\u00e9gner Piles et files Arbres Arbres binaires de recherche Recherche textuelle Graphes Graphes pond\u00e9r\u00e9s Calculabilit\u00e9 et d\u00e9cidabilit\u00e9","title":"Programme du cours"},{"location":"#sujets-et-corriges-des-devoirs","text":"Devoirs maison Immeubles al\u00e9atoires Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici S\u00e9ismes Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Casse-briques Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Traitement d'une image Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Devoirs surveill\u00e9s 1 Sujet de la premi\u00e8re partie \u00e0 t\u00e9l\u00e9charger ici Sujet de la seconde partie \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici \u00c9preuves pratiques 01 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 02 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 16 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 17 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 18 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 19 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 20 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 23 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 26 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 29 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici","title":"Sujets et corrig\u00e9s des devoirs"},{"location":"#logiciels-a-installer","text":"Installation d'Anaconda La suite Anaconda , t\u00e9l\u00e9chargeable ici , contient l'\u00e9diteur de carnets Jupyter et l'\u00e9diteur de code Spyder .","title":"Logiciels \u00e0 installer"},{"location":"abr/","text":"Chapitre 10 : Arbres binaires de recherche","title":"Arbres binaires de recherche"},{"location":"abr/#chapitre-10-arbres-binaires-de-recherche","text":"","title":"Chapitre 10 : Arbres binaires de recherche"},{"location":"api/","text":"Chapitre 1 : Interfaces de programmation d'applications Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Cahier \u00e0 t\u00e9l\u00e9charger ici Une API ( Application Programming Interface ), ou une interface de programmation d\u2019applications , est un ensemble de classes, fonctions, constantes gr\u00e2ce auquel un programme fournisseur met \u00e0 disposition diverses fonctionnalit\u00e9s pour des programmes consommateurs . C'est le programme fournisseur qui d\u00e9finit de quelle fa\u00e7on les fonctionnalit\u00e9s sont mises \u00e0 disposition des consommateurs, en imposant \u00e9ventuellement un certain nombre de contraintes d'acc\u00e8s \u00e0 l'API. On s'int\u00e9resse ici \u00e0 la Base Adresse Nationale qui est une API gratuite du gouvernement fran\u00e7ais permettant d'obtenir un certain nombre d'informations \u00e0 partir d'une adresse postale. Interrogation de l'API On souhaite, gr\u00e2ce \u00e0 l'API, obtenir des informations sur l'adresse postale du lyc\u00e9e Louis Armand. Pour interroger l'API, il suffit d'envoyer une requ\u00eate GET \u00e0 l'URL https://api-adresse.data.gouv.fr/search/?q=173-boulevard-de-strasbourg&postcode=94130 . On remarque que l'adresse postale sur laquelle on souhaite interroger l'API est indiqu\u00e9e dans l'URL. La r\u00e9ponse renvoy\u00e9e par l'API est la suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { \"type\" : \"FeatureCollection\" , \"version\" : \"draft\" , \"features\" : [{ \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.491306 , 48.846716 ]}, \"properties\" : { \"label\" : \"173 Boulevard de Strasbourg 94130 Nogent-sur-Marne\" , \"score\" : 0.88381 , \"housenumber\" : \"173\" , \"id\" : \"94052_8560_00173\" , \"name\" : \"173 Boulevard de Strasbourg\" , \"postcode\" : \"94130\" , \"citycode\" : \"94052\" , \"x\" : 662668.4 , \"y\" : 6860861.49 , \"city\" : \"Nogent-sur-Marne\" , \"context\" : \"94, Val-de-Marne, \u00cele-de-France\" , \"type\" : \"housenumber\" , \"importance\" : 0.72191 , \"street\" : \"Boulevard de Strasbourg\" }}], \"attribution\" : \"BAN\" , \"licence\" : \"ETALAB-2.0\" , \"query\" : \"173-boulevard-de-strasbourg\" , \"filters\" : { \"postcode\" : \"94130\" }, \"limit\" : 5 } La r\u00e9ponse re\u00e7ue est au format JSON ( JavaScript Object Notation ). La signification des champs de la r\u00e9ponse est donn\u00e9e dans la documentation de l'API. L'interrogation de l'API peut \u00eatre r\u00e9alis\u00e9e gr\u00e2ce au code Python ci-dessous. Lors de son ex\u00e9cution, la r\u00e9ponse renvoy\u00e9e par l'API est stock\u00e9e dans la variable reponse . Impl\u00e9mentation 1 2 3 4 import requests url = \"https://api-adresse.data.gouv.fr/search/?q=173-boulevard-de-strasbourg&postcode=94130\" reponse = requests . get ( url ) reponse = reponse . json () La fonction get du module requests permet d'envoyer une requ\u00eate GET \u00e0 l'URL sp\u00e9cifi\u00e9e et ensuite de r\u00e9cup\u00e9rer la r\u00e9ponse. La commande reponse.json() extrait de la r\u00e9ponse les donn\u00e9es encod\u00e9es dans le format JSON, qui est un format de donn\u00e9es textuelles que l'on peut traiter comme s'il s'agissait d'un dictionnaire Python. Traitement de la r\u00e9ponse renvoy\u00e9e par l'API Il est possible de d\u00e9finir une fonction qui interroge l'API \u00e0 partir d'une adresse postale au choix, pass\u00e9e en param\u00e8tre. Premi\u00e8re version : donn\u00e9es compl\u00e8tes Fonction interroger_API_BAN Interroge l'API Base Adresse Nationale . Entr\u00e9es adresse : cha\u00eene de caract\u00e8res code_postal : entier ou cha\u00eene de caract\u00e8res Sortie reponse : dictionnaire contenant l'ensemble des donn\u00e9es renvoy\u00e9es par l'API Penser \u00e0 importer le module requests ! Impl\u00e9mentation 1 2 3 4 5 def interroger_API_BAN ( adresse , code_postal ): url = f \"https://api-adresse.data.gouv.fr/search/?q= { adresse } &postcode= { code_postal } \" reponse = requests . get ( url ) reponse = reponse . json () return reponse L'utilisation d'une f-string pour l'\u00e9criture de l'URL permet d'y int\u00e9grer simplement et lisiblement les param\u00e8tres d'entr\u00e9e de la fonction. Ici, la fonction renvoie l'ensemble des donn\u00e9es r\u00e9cup\u00e9r\u00e9es via l'API. La plupart du temps, on souhaite n\u00e9anmoins isoler les donn\u00e9es qui nous int\u00e9ressent et elles seules. Seconde version : donn\u00e9es s\u00e9lectionn\u00e9es Fonction interroger_API_BAN Renvoie les coordonn\u00e9es g\u00e9ographiques d'un lieu apr\u00e8s interrogation de l'API Base Adresse Nationale . Entr\u00e9es adresse : cha\u00eene de caract\u00e8res code_postal : entier ou cha\u00eene de caract\u00e8res Sortie (lat, long) : couple de coordonn\u00e9es g\u00e9ographiques Penser \u00e0 importer le module requests ! Impl\u00e9mentation 1 2 3 4 5 6 7 8 def interroger_API_BAN ( adresse , code_postal ): url = f \"https://api-adresse.data.gouv.fr/search/?q= { adresse } &postcode= { code_postal } \" reponse = requests . get ( url ) reponse = reponse . json () coord = reponse [ 'features' ][ 0 ][ 'geometry' ][ 'coordinates' ] long = coord [ 0 ] lat = coord [ 1 ] return ( lat , long ) Une fois la r\u00e9ponse de l'API transform\u00e9e en dictionnaire, il suffit de naviguer pour r\u00e9cup\u00e9rer les donn\u00e9es qui nous int\u00e9ressent, comme par exemple les coordonn\u00e9es g\u00e9ographiques de l'adresse pass\u00e9e en param\u00e8tre. reponse est un dictionnaire poss\u00e9dant huit cl\u00e9s : 'type' , 'version' , 'features' , 'attribution' , 'licence' , 'query' , 'filters' et 'limit' . reponse['features'] est un tableau contenant un ou plusieurs \u00e9l\u00e9ments de type dictionnaire : chaque dictionnaire correspond \u00e0 une adresse potentielle, la premi\u00e8re (indice 0 ) \u00e9tant la plus susceptible de correspondre \u00e0 notre demande. reponse['features'][0] est un dictionnaire poss\u00e9dant trois cl\u00e9s : 'type' , 'geometry' et 'properties' . reponse['features'][0]['geometry'] est un dictionnaire poss\u00e9dant deux cl\u00e9s : 'type' et 'coordinates' . reponse['features'][0]['geometry']['coordinates'] est un tableau contenant deux \u00e9l\u00e9ments de type flottant : la longitude (indice 0 ) et la latitude (indice 1 ) du lieu. Ce qu'il faut savoir et savoir faire Envoyer une requ\u00eate \u00e0 une API avec le module requests . S\u00e9lectionner des informations dans la r\u00e9ponse renvoy\u00e9e par une API. Consulter la documentation d'une API. Exercices et activit\u00e9s Exercices Ast\u00e9ro\u00efdes \u00e0 surveiller Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Bulletin m\u00e9t\u00e9o Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Composition des produits alimentaires Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici D\u00e9coupage administratif Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Activit\u00e9s Carte de vigilance m\u00e9t\u00e9orologique L'objectif de l'activit\u00e9 est d'utiliser une API pour r\u00e9aliser une carte de vigilance m\u00e9t\u00e9orologique. Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici \u26a0\ufe0f Le fichier carte_france.py doit \u00eatre plac\u00e9 dans le m\u00eame r\u00e9pertoire que le carnet act_vigilance_meteo.ipynb . Corrig\u00e9 disponible ici Centres de vaccination anti-Covid L'objectif de l'activit\u00e9 est d'utiliser une API pour cartographier les centres de vaccination anti-Covid d'un d\u00e9partement. Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Station spatiale internationale L'objectif de l'activit\u00e9 est d'utiliser une API pour suivre les d\u00e9placements de la station spatiale internationale. Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici","title":"Interfaces de programmation d'applications"},{"location":"api/#chapitre-1-interfaces-de-programmation-dapplications","text":"Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Cahier \u00e0 t\u00e9l\u00e9charger ici Une API ( Application Programming Interface ), ou une interface de programmation d\u2019applications , est un ensemble de classes, fonctions, constantes gr\u00e2ce auquel un programme fournisseur met \u00e0 disposition diverses fonctionnalit\u00e9s pour des programmes consommateurs . C'est le programme fournisseur qui d\u00e9finit de quelle fa\u00e7on les fonctionnalit\u00e9s sont mises \u00e0 disposition des consommateurs, en imposant \u00e9ventuellement un certain nombre de contraintes d'acc\u00e8s \u00e0 l'API. On s'int\u00e9resse ici \u00e0 la Base Adresse Nationale qui est une API gratuite du gouvernement fran\u00e7ais permettant d'obtenir un certain nombre d'informations \u00e0 partir d'une adresse postale.","title":"Chapitre 1 : Interfaces de programmation d'applications"},{"location":"api/#interrogation-de-lapi","text":"On souhaite, gr\u00e2ce \u00e0 l'API, obtenir des informations sur l'adresse postale du lyc\u00e9e Louis Armand. Pour interroger l'API, il suffit d'envoyer une requ\u00eate GET \u00e0 l'URL https://api-adresse.data.gouv.fr/search/?q=173-boulevard-de-strasbourg&postcode=94130 . On remarque que l'adresse postale sur laquelle on souhaite interroger l'API est indiqu\u00e9e dans l'URL. La r\u00e9ponse renvoy\u00e9e par l'API est la suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { \"type\" : \"FeatureCollection\" , \"version\" : \"draft\" , \"features\" : [{ \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.491306 , 48.846716 ]}, \"properties\" : { \"label\" : \"173 Boulevard de Strasbourg 94130 Nogent-sur-Marne\" , \"score\" : 0.88381 , \"housenumber\" : \"173\" , \"id\" : \"94052_8560_00173\" , \"name\" : \"173 Boulevard de Strasbourg\" , \"postcode\" : \"94130\" , \"citycode\" : \"94052\" , \"x\" : 662668.4 , \"y\" : 6860861.49 , \"city\" : \"Nogent-sur-Marne\" , \"context\" : \"94, Val-de-Marne, \u00cele-de-France\" , \"type\" : \"housenumber\" , \"importance\" : 0.72191 , \"street\" : \"Boulevard de Strasbourg\" }}], \"attribution\" : \"BAN\" , \"licence\" : \"ETALAB-2.0\" , \"query\" : \"173-boulevard-de-strasbourg\" , \"filters\" : { \"postcode\" : \"94130\" }, \"limit\" : 5 } La r\u00e9ponse re\u00e7ue est au format JSON ( JavaScript Object Notation ). La signification des champs de la r\u00e9ponse est donn\u00e9e dans la documentation de l'API. L'interrogation de l'API peut \u00eatre r\u00e9alis\u00e9e gr\u00e2ce au code Python ci-dessous. Lors de son ex\u00e9cution, la r\u00e9ponse renvoy\u00e9e par l'API est stock\u00e9e dans la variable reponse . Impl\u00e9mentation 1 2 3 4 import requests url = \"https://api-adresse.data.gouv.fr/search/?q=173-boulevard-de-strasbourg&postcode=94130\" reponse = requests . get ( url ) reponse = reponse . json () La fonction get du module requests permet d'envoyer une requ\u00eate GET \u00e0 l'URL sp\u00e9cifi\u00e9e et ensuite de r\u00e9cup\u00e9rer la r\u00e9ponse. La commande reponse.json() extrait de la r\u00e9ponse les donn\u00e9es encod\u00e9es dans le format JSON, qui est un format de donn\u00e9es textuelles que l'on peut traiter comme s'il s'agissait d'un dictionnaire Python.","title":"Interrogation de l'API"},{"location":"api/#traitement-de-la-reponse-renvoyee-par-lapi","text":"Il est possible de d\u00e9finir une fonction qui interroge l'API \u00e0 partir d'une adresse postale au choix, pass\u00e9e en param\u00e8tre. Premi\u00e8re version : donn\u00e9es compl\u00e8tes Fonction interroger_API_BAN Interroge l'API Base Adresse Nationale . Entr\u00e9es adresse : cha\u00eene de caract\u00e8res code_postal : entier ou cha\u00eene de caract\u00e8res Sortie reponse : dictionnaire contenant l'ensemble des donn\u00e9es renvoy\u00e9es par l'API Penser \u00e0 importer le module requests ! Impl\u00e9mentation 1 2 3 4 5 def interroger_API_BAN ( adresse , code_postal ): url = f \"https://api-adresse.data.gouv.fr/search/?q= { adresse } &postcode= { code_postal } \" reponse = requests . get ( url ) reponse = reponse . json () return reponse L'utilisation d'une f-string pour l'\u00e9criture de l'URL permet d'y int\u00e9grer simplement et lisiblement les param\u00e8tres d'entr\u00e9e de la fonction. Ici, la fonction renvoie l'ensemble des donn\u00e9es r\u00e9cup\u00e9r\u00e9es via l'API. La plupart du temps, on souhaite n\u00e9anmoins isoler les donn\u00e9es qui nous int\u00e9ressent et elles seules. Seconde version : donn\u00e9es s\u00e9lectionn\u00e9es Fonction interroger_API_BAN Renvoie les coordonn\u00e9es g\u00e9ographiques d'un lieu apr\u00e8s interrogation de l'API Base Adresse Nationale . Entr\u00e9es adresse : cha\u00eene de caract\u00e8res code_postal : entier ou cha\u00eene de caract\u00e8res Sortie (lat, long) : couple de coordonn\u00e9es g\u00e9ographiques Penser \u00e0 importer le module requests ! Impl\u00e9mentation 1 2 3 4 5 6 7 8 def interroger_API_BAN ( adresse , code_postal ): url = f \"https://api-adresse.data.gouv.fr/search/?q= { adresse } &postcode= { code_postal } \" reponse = requests . get ( url ) reponse = reponse . json () coord = reponse [ 'features' ][ 0 ][ 'geometry' ][ 'coordinates' ] long = coord [ 0 ] lat = coord [ 1 ] return ( lat , long ) Une fois la r\u00e9ponse de l'API transform\u00e9e en dictionnaire, il suffit de naviguer pour r\u00e9cup\u00e9rer les donn\u00e9es qui nous int\u00e9ressent, comme par exemple les coordonn\u00e9es g\u00e9ographiques de l'adresse pass\u00e9e en param\u00e8tre. reponse est un dictionnaire poss\u00e9dant huit cl\u00e9s : 'type' , 'version' , 'features' , 'attribution' , 'licence' , 'query' , 'filters' et 'limit' . reponse['features'] est un tableau contenant un ou plusieurs \u00e9l\u00e9ments de type dictionnaire : chaque dictionnaire correspond \u00e0 une adresse potentielle, la premi\u00e8re (indice 0 ) \u00e9tant la plus susceptible de correspondre \u00e0 notre demande. reponse['features'][0] est un dictionnaire poss\u00e9dant trois cl\u00e9s : 'type' , 'geometry' et 'properties' . reponse['features'][0]['geometry'] est un dictionnaire poss\u00e9dant deux cl\u00e9s : 'type' et 'coordinates' . reponse['features'][0]['geometry']['coordinates'] est un tableau contenant deux \u00e9l\u00e9ments de type flottant : la longitude (indice 0 ) et la latitude (indice 1 ) du lieu.","title":"Traitement de la r\u00e9ponse renvoy\u00e9e par l'API"},{"location":"api/#ce-quil-faut-savoir-et-savoir-faire","text":"Envoyer une requ\u00eate \u00e0 une API avec le module requests . S\u00e9lectionner des informations dans la r\u00e9ponse renvoy\u00e9e par une API. Consulter la documentation d'une API.","title":"Ce qu'il faut savoir et savoir faire"},{"location":"api/#exercices-et-activites","text":"Exercices Ast\u00e9ro\u00efdes \u00e0 surveiller Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Bulletin m\u00e9t\u00e9o Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Composition des produits alimentaires Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici D\u00e9coupage administratif Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Activit\u00e9s Carte de vigilance m\u00e9t\u00e9orologique L'objectif de l'activit\u00e9 est d'utiliser une API pour r\u00e9aliser une carte de vigilance m\u00e9t\u00e9orologique. Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici \u26a0\ufe0f Le fichier carte_france.py doit \u00eatre plac\u00e9 dans le m\u00eame r\u00e9pertoire que le carnet act_vigilance_meteo.ipynb . Corrig\u00e9 disponible ici Centres de vaccination anti-Covid L'objectif de l'activit\u00e9 est d'utiliser une API pour cartographier les centres de vaccination anti-Covid d'un d\u00e9partement. Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Station spatiale internationale L'objectif de l'activit\u00e9 est d'utiliser une API pour suivre les d\u00e9placements de la station spatiale internationale. Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici","title":"Exercices et activit\u00e9s"},{"location":"arbres/","text":"Chapitre 9 : Arbres","title":"Arbres"},{"location":"arbres/#chapitre-9-arbres","text":"","title":"Chapitre 9 : Arbres"},{"location":"calculabilite/","text":"Chapitre 14 : Calculabilit\u00e9 et d\u00e9cidabilit\u00e9","title":"Calculabilit\u00e9 et d\u00e9cidabilit\u00e9"},{"location":"calculabilite/#chapitre-14-calculabilite-et-decidabilite","text":"","title":"Chapitre 14 : Calculabilit\u00e9 et d\u00e9cidabilit\u00e9"},{"location":"diviser/","text":"Chapitre 7 : M\u00e9thode diviser pour r\u00e9gner","title":"M\u00e9thode diviser pour r\u00e9gner"},{"location":"diviser/#chapitre-7-methode-diviser-pour-regner","text":"","title":"Chapitre 7 : M\u00e9thode diviser pour r\u00e9gner"},{"location":"exemple/","text":"Titre Sous titre Document joint Exercice Exercice suppl\u00e9mentaire Activit\u00e9 Bla bla bla bla bla... Solution R\u00e9ponses au probl\u00e8me.... A retenir Sur le cahier Erreur Important !","title":"Titre"},{"location":"exemple/#titre","text":"","title":"Titre"},{"location":"exemple/#sous-titre","text":"Document joint Exercice Exercice suppl\u00e9mentaire Activit\u00e9 Bla bla bla bla bla... Solution R\u00e9ponses au probl\u00e8me.... A retenir Sur le cahier Erreur Important !","title":"Sous titre"},{"location":"graphes/","text":"Chapitre 12 : Graphes","title":"Graphes"},{"location":"graphes/#chapitre-12-graphes","text":"","title":"Chapitre 12 : Graphes"},{"location":"graphes_pond/","text":"Chapitre 13 : Graphes pond\u00e9r\u00e9s","title":"Graphes pond\u00e9r\u00e9s"},{"location":"graphes_pond/#chapitre-13-graphes-ponderes","text":"","title":"Chapitre 13 : Graphes pond\u00e9r\u00e9s"},{"location":"listes/","text":"Chapitre 5 : Listes cha\u00een\u00e9es","title":"Listes cha\u00een\u00e9es"},{"location":"listes/#chapitre-5-listes-chainees","text":"","title":"Chapitre 5 : Listes cha\u00een\u00e9es"},{"location":"mise_au_point/","text":"Chapitre 6 : Mise au point de programmes","title":"Mise au point de programmes"},{"location":"mise_au_point/#chapitre-6-mise-au-point-de-programmes","text":"","title":"Chapitre 6 : Mise au point de programmes"},{"location":"modularite/","text":"Chapitre 4 : Modularit\u00e9","title":"Chapitre 4 : Modularit\u00e9"},{"location":"modularite/#chapitre-4-modularite","text":"","title":"Chapitre 4 : Modularit\u00e9"},{"location":"patience/","text":"Un peu de patience !","title":"Modularit\u00e9"},{"location":"patience/#un-peu-de-patience","text":"","title":"Un peu de patience !"},{"location":"piles_files/","text":"Chapitre 8 : Piles et files","title":"Piles et files"},{"location":"piles_files/#chapitre-8-piles-et-files","text":"","title":"Chapitre 8 : Piles et files"},{"location":"prog_objet/","text":"Chapitre 3 : Programmation objet Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici (bient\u00f4t disponible) Cahier \u00e0 t\u00e9l\u00e9charger ici (bient\u00f4t disponible) Parmi les types de base \u00e9tudi\u00e9s en Premi\u00e8re et que nous avons l'habitude de manipuler, on peut citer : des types simples comme les types num\u00e9riques entier ( int ) et flottant ( float ), le type bool\u00e9en ( bool ) ou le type cha\u00eene de caract\u00e8res ( str ), des types construits comme les types tableau ( list ), p-uplet ( tuple ) et dictionnaire ( dict ). Le type d'un objet d\u00e9termine ce qu'on peut faire avec, par exemple : l'op\u00e9rateur + peut s'utiliser entre deux nombres, entre deux cha\u00eenes, entre deux tableaux, mais pas entre un nombre et une cha\u00eene... append peut s'utiliser pour ajouter un \u00e9l\u00e9ment \u00e0 la fin d'un tableau, mais pas \u00e0 la fin d'une cha\u00eene ou d'un puplet... len donne la longueur d'une cha\u00eene, d'un tableau, d'un p-uplet ou d'un dictionnaire, mais pas d'un nombre ou d'un bool\u00e9en... etc . Le but de ce chapitre est d'apprendre \u00e0 d\u00e9finir nos propres types personnalis\u00e9s , appel\u00e9s classes , dont nous pourrons d\u00e9cider de la structure et des utilisations possibles. Cr\u00e9ation d'une classe On cr\u00e9e une classe appel\u00e9e Montre en \u00e9crivant class Montre: . Par convention, les noms de classes sont de la forme NomDeClasse , avec une majuscule au d\u00e9but de chaque mot, sans espace entre les mots. 1 2 class Montre : \"\"\"Pour l'instant, la classe est vide et ne sert \u00e0 rien...\"\"\" On peut d\u00e9sormais cr\u00e9er une variable ma_montre de \"type\" Montre . Plus pr\u00e9cis\u00e9ment, on dit que ma_montre est une instance de la classe Montre . 1 ma_montre = Montre () L'int\u00e9r\u00eat d'une classe est que ses instances peuvent poss\u00e9der des attributs , qui permettent de stocker des donn\u00e9es, et des m\u00e9thodes , qui permettent de modifier ces donn\u00e9es. La partie de la documentation officielle de Python qui traite des classes commence comme ceci : Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state. Class instances can also have methods (defined by its class) for modifying its state. On souhaite que les instances de la classe Montre poss\u00e8dent trois attributs h , m et s . Pour cela, on d\u00e9finit une m\u00e9thode, dite m\u00e9thode constructeur et nomm\u00e9e __init__ , qui est appel\u00e9e automatiquement lors de la cr\u00e9ation d'une instance de la classe. Instanciation avec valeurs par d\u00e9faut pour les attributs L'initialisation des attributs peut se faire avec des valeurs par d\u00e9faut, par exemple 0. 1 2 3 4 5 6 7 8 class Montre : def __init__ ( self ): \"\"\"M\u00e9thode constructeur initialisant les attributs \u00e0 la valeur par d\u00e9faut 0.\"\"\" self . h = 0 self . m = 0 self . s = 0 ma_montre = Montre () # cr\u00e9ation d'une instance de la classe Montre La premi\u00e8re ligne d'une m\u00e9thode est semblable \u00e0 celle d'une fonction : def nom_methode(parametres): . Le param\u00e8tre self est toujours le premier param\u00e8tre d'entr\u00e9e d'une m\u00e9thode (et c'est parfois le seul, comme ici). Il repr\u00e9sente l'instance sur laquelle la m\u00e9thode est appel\u00e9e. Pour acc\u00e9der \u00e0 la valeur d'un attribut, la syntaxe \u00e0 utiliser est instance.attribut . Instanciation avec valeurs pass\u00e9es en arguments pour les attributs L'initialisation des attributs peut se faire avec des valeurs choisies au moment de la cr\u00e9ation de l'instance de classe. 1 2 3 4 5 6 7 8 class Montre : def __init__ ( self , h , m , s ): \"\"\"M\u00e9thode constructeur initialisant les attributs aux valeurs h, m, s pass\u00e9es en argument.\"\"\" self . h = h self . m = m self . s = s ma_montre = Montre ( 13 , 30 , 0 ) # cr\u00e9ation d'une instance de la classe Montre La m\u00e9thode __init__ poss\u00e8de ici quatre param\u00e8tres d'entr\u00e9e, le premier \u00e9tant self . On remarque n\u00e9anmoins que, lors de la cr\u00e9ation de l'instance ma_montre , seules trois valeurs (qui correspondent \u00e0 h , m et s sont pass\u00e9es en arguments. D\u00e9finition de m\u00e9thodes On peut ajouter \u00e0 la classe Montre la d\u00e9finition de m\u00e9thodes dont le r\u00f4le est de permettre de modifier les instances de la classe. M\u00e9thode incr\u00e9menter Par exemple, le r\u00f4le de la m\u00e9thode incr\u00e9menter est d'avancer la montre d'une seconde. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Montre : def __init__ ( self , h , m , s ): \"\"\"M\u00e9thode constructeur initialisant les attributs aux valeurs h, m, s pass\u00e9es en argument.\"\"\" self . h = h self . m = m self . s = s def incrementer ( self ): \"\"\"Avance la montre d'une seconde.\"\"\" if self . s < 59 : self . s += 1 else : self . s = 0 if self . m < 59 : self . m += 1 else : self . m = 0 if self . h < 23 : self . h += 1 else : self . h = 0 Lorsque la m\u00e9thode incrementer est appel\u00e9e pour une instance de la classe Montre , la valeur de l'attribut s est modifi\u00e9e pour cette instance. La valeur des attributs m et h peut \u00eatre modifi\u00e9e \u00e9galement. La syntaxe instance.methode() permet d'appeler une m\u00e9thode qui ne prend pas d'argument en entr\u00e9e (autre que self ). M\u00e9thode avancer Le r\u00f4le de la m\u00e9thode avancer est d'avancer la montre de plusieurs secondes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Montre : def __init__ ( self , h , m , s ): \"\"\"M\u00e9thode constructeur initialisant les attributs aux valeurs h, m, s pass\u00e9es en argument.\"\"\" self . h = h self . m = m self . s = s def incrementer ( self ): \"\"\"Avance la montre d'une seconde.\"\"\" if self . s < 59 : self . s += 1 else : self . s = 0 if self . m < 59 : self . m += 1 else : self . m = 0 if self . h < 23 : self . h += 1 else : self . h = 0 def avancer ( self , n ): \"\"\"Avance la montre de n secondes.\"\"\" for _ in range ( n ): self . incrementer () Lorsque la m\u00e9thode avancer est appel\u00e9e pour une instance de la classe Montre , la m\u00e9thode incrementer est appel\u00e9e n fois pour cette instance elle-m\u00eame (d'o\u00f9 la commande self.incrementer() . La syntaxe instance.methode(arguments) permet d'appeler une m\u00e9thode qui prend un ou plusieurs arguments en entr\u00e9e (autres que self ). M\u00e9thode synchroniser La fonction localtime du module time permet de conna\u00eetre l'heure locale au moment de l'appel de la fonction. L'objet renvoy\u00e9 poss\u00e8de (entre autres) trois attributs tm_hour , tm_min et tm_sec qui donnent respectivement l'heure, les minutes et les secondes de l'heure locale. On peut ajouter \u00e0 la d\u00e9finition de la classe Montre une m\u00e9thode synchroniser dont le r\u00f4le est de mettre la montre \u00e0 l'heure. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from time import localtime class Montre : def __init__ ( self , h , m , s ): \"\"\"M\u00e9thode constructeur initialisant les attributs aux valeurs h, m, s pass\u00e9es en argument.\"\"\" self . h = h self . m = m self . s = s def synchroniser ( self ): \"\"\"Synchronise la montre \u00e0 l'heure locale du moment de l'appel.\"\"\" heure_locale = localtime () self . h = heure_locale . tm_hour self . m = heure_locale . tm_min self . s = heure_locale . tm_sec Lorsque la m\u00e9thode synchroniser est appel\u00e9e pour une instance de la classe Montre , la valeur des attributs h , m et s est modifi\u00e9e pour cette instance. M\u00e9thode sp\u00e9ciale __str__ Si on souhaite afficher \u00e0 l'\u00e9cran l'heure de la montre, on peut se demander ce que donnerait l'instruction print(ma_montre) . L'affichage obtenu <__main__.Montre object at 0x7f45dc1f9350> n'est pas lisible, hormis la r\u00e9f\u00e9rence au fait que ma_montre est un objet de \"type\" Montre . Il est n\u00e9anmoins possible de faire appara\u00eetre un affichage personnalis\u00e9 beaucoup plus lisible de l'objet en d\u00e9finissant une m\u00e9thode sp\u00e9ciale nomm\u00e9e __str__ . 1 2 3 4 5 6 7 8 9 10 class Montre : def __init__ ( self , h , m , s ): \"\"\"M\u00e9thode constructeur initialisant les attributs aux valeurs h, m, s pass\u00e9es en argument.\"\"\" self . h = h self . m = m self . s = s def __str__ ( self ): \"\"\"Affiche l'heure de la montre au format HH:MM:SS.\"\"\" return f \" { self . h } : { self . m } : { self . s } \" La m\u00e9thode sp\u00e9ciale __str__ est cr\u00e9e pour \u00eatre appel\u00e9e par la fonction print . Elle doit donc renvoyer une cha\u00eene de caract\u00e8res. Ce qu'il faut savoir et savoir faire Conna\u00eetre le vocabulaire de la programmation objet, en particulier la notion de classe, d'instance, d'attribut et de m\u00e9thode. Utiliser la notation point\u00e9e instance.attribut et instance.methode(arguments) . D\u00e9finir une classe, cr\u00e9er une instance et g\u00e9rer l'initialisation des attributs d'instance gr\u00e2ce \u00e0 la m\u00e9thode __init__ . D\u00e9finir une m\u00e9thode et comprendre l'utilisation du param\u00e8tre self . Exercices et activit\u00e9s Exercices Compte bancaire Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Date Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Dominos (bient\u00f4t disponible) Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Labyrinthe (bient\u00f4t disponible) Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Activit\u00e9s Balle rebondissante L'objectif de l'activit\u00e9 est de faire rebondir une balle dans une fen\u00eatre graphique. Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici \u26a0\ufe0f Le fichier balle_pygame.py doit \u00eatre plac\u00e9 dans le m\u00eame r\u00e9pertoire que le carnet act_balle_rebondissante.ipynb . Corrig\u00e9 disponible ici Ensembles de Mandelbrot et de Julia L'objectif de l'activit\u00e9 est de repr\u00e9senter des fractales c\u00e9l\u00e8bres : l'ensemble de Mandelbrot et les ensembles de Julia. Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Fractions (bient\u00f4t disponible) Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Paquet de cartes (bient\u00f4t disponible) Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici","title":"Programmation objet"},{"location":"prog_objet/#chapitre-3-programmation-objet","text":"Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici (bient\u00f4t disponible) Cahier \u00e0 t\u00e9l\u00e9charger ici (bient\u00f4t disponible) Parmi les types de base \u00e9tudi\u00e9s en Premi\u00e8re et que nous avons l'habitude de manipuler, on peut citer : des types simples comme les types num\u00e9riques entier ( int ) et flottant ( float ), le type bool\u00e9en ( bool ) ou le type cha\u00eene de caract\u00e8res ( str ), des types construits comme les types tableau ( list ), p-uplet ( tuple ) et dictionnaire ( dict ). Le type d'un objet d\u00e9termine ce qu'on peut faire avec, par exemple : l'op\u00e9rateur + peut s'utiliser entre deux nombres, entre deux cha\u00eenes, entre deux tableaux, mais pas entre un nombre et une cha\u00eene... append peut s'utiliser pour ajouter un \u00e9l\u00e9ment \u00e0 la fin d'un tableau, mais pas \u00e0 la fin d'une cha\u00eene ou d'un puplet... len donne la longueur d'une cha\u00eene, d'un tableau, d'un p-uplet ou d'un dictionnaire, mais pas d'un nombre ou d'un bool\u00e9en... etc . Le but de ce chapitre est d'apprendre \u00e0 d\u00e9finir nos propres types personnalis\u00e9s , appel\u00e9s classes , dont nous pourrons d\u00e9cider de la structure et des utilisations possibles.","title":"Chapitre 3 : Programmation objet"},{"location":"prog_objet/#creation-dune-classe","text":"On cr\u00e9e une classe appel\u00e9e Montre en \u00e9crivant class Montre: . Par convention, les noms de classes sont de la forme NomDeClasse , avec une majuscule au d\u00e9but de chaque mot, sans espace entre les mots. 1 2 class Montre : \"\"\"Pour l'instant, la classe est vide et ne sert \u00e0 rien...\"\"\" On peut d\u00e9sormais cr\u00e9er une variable ma_montre de \"type\" Montre . Plus pr\u00e9cis\u00e9ment, on dit que ma_montre est une instance de la classe Montre . 1 ma_montre = Montre () L'int\u00e9r\u00eat d'une classe est que ses instances peuvent poss\u00e9der des attributs , qui permettent de stocker des donn\u00e9es, et des m\u00e9thodes , qui permettent de modifier ces donn\u00e9es. La partie de la documentation officielle de Python qui traite des classes commence comme ceci : Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state. Class instances can also have methods (defined by its class) for modifying its state. On souhaite que les instances de la classe Montre poss\u00e8dent trois attributs h , m et s . Pour cela, on d\u00e9finit une m\u00e9thode, dite m\u00e9thode constructeur et nomm\u00e9e __init__ , qui est appel\u00e9e automatiquement lors de la cr\u00e9ation d'une instance de la classe. Instanciation avec valeurs par d\u00e9faut pour les attributs L'initialisation des attributs peut se faire avec des valeurs par d\u00e9faut, par exemple 0. 1 2 3 4 5 6 7 8 class Montre : def __init__ ( self ): \"\"\"M\u00e9thode constructeur initialisant les attributs \u00e0 la valeur par d\u00e9faut 0.\"\"\" self . h = 0 self . m = 0 self . s = 0 ma_montre = Montre () # cr\u00e9ation d'une instance de la classe Montre La premi\u00e8re ligne d'une m\u00e9thode est semblable \u00e0 celle d'une fonction : def nom_methode(parametres): . Le param\u00e8tre self est toujours le premier param\u00e8tre d'entr\u00e9e d'une m\u00e9thode (et c'est parfois le seul, comme ici). Il repr\u00e9sente l'instance sur laquelle la m\u00e9thode est appel\u00e9e. Pour acc\u00e9der \u00e0 la valeur d'un attribut, la syntaxe \u00e0 utiliser est instance.attribut . Instanciation avec valeurs pass\u00e9es en arguments pour les attributs L'initialisation des attributs peut se faire avec des valeurs choisies au moment de la cr\u00e9ation de l'instance de classe. 1 2 3 4 5 6 7 8 class Montre : def __init__ ( self , h , m , s ): \"\"\"M\u00e9thode constructeur initialisant les attributs aux valeurs h, m, s pass\u00e9es en argument.\"\"\" self . h = h self . m = m self . s = s ma_montre = Montre ( 13 , 30 , 0 ) # cr\u00e9ation d'une instance de la classe Montre La m\u00e9thode __init__ poss\u00e8de ici quatre param\u00e8tres d'entr\u00e9e, le premier \u00e9tant self . On remarque n\u00e9anmoins que, lors de la cr\u00e9ation de l'instance ma_montre , seules trois valeurs (qui correspondent \u00e0 h , m et s sont pass\u00e9es en arguments.","title":"Cr\u00e9ation d'une classe"},{"location":"prog_objet/#definition-de-methodes","text":"On peut ajouter \u00e0 la classe Montre la d\u00e9finition de m\u00e9thodes dont le r\u00f4le est de permettre de modifier les instances de la classe. M\u00e9thode incr\u00e9menter Par exemple, le r\u00f4le de la m\u00e9thode incr\u00e9menter est d'avancer la montre d'une seconde. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Montre : def __init__ ( self , h , m , s ): \"\"\"M\u00e9thode constructeur initialisant les attributs aux valeurs h, m, s pass\u00e9es en argument.\"\"\" self . h = h self . m = m self . s = s def incrementer ( self ): \"\"\"Avance la montre d'une seconde.\"\"\" if self . s < 59 : self . s += 1 else : self . s = 0 if self . m < 59 : self . m += 1 else : self . m = 0 if self . h < 23 : self . h += 1 else : self . h = 0 Lorsque la m\u00e9thode incrementer est appel\u00e9e pour une instance de la classe Montre , la valeur de l'attribut s est modifi\u00e9e pour cette instance. La valeur des attributs m et h peut \u00eatre modifi\u00e9e \u00e9galement. La syntaxe instance.methode() permet d'appeler une m\u00e9thode qui ne prend pas d'argument en entr\u00e9e (autre que self ). M\u00e9thode avancer Le r\u00f4le de la m\u00e9thode avancer est d'avancer la montre de plusieurs secondes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Montre : def __init__ ( self , h , m , s ): \"\"\"M\u00e9thode constructeur initialisant les attributs aux valeurs h, m, s pass\u00e9es en argument.\"\"\" self . h = h self . m = m self . s = s def incrementer ( self ): \"\"\"Avance la montre d'une seconde.\"\"\" if self . s < 59 : self . s += 1 else : self . s = 0 if self . m < 59 : self . m += 1 else : self . m = 0 if self . h < 23 : self . h += 1 else : self . h = 0 def avancer ( self , n ): \"\"\"Avance la montre de n secondes.\"\"\" for _ in range ( n ): self . incrementer () Lorsque la m\u00e9thode avancer est appel\u00e9e pour une instance de la classe Montre , la m\u00e9thode incrementer est appel\u00e9e n fois pour cette instance elle-m\u00eame (d'o\u00f9 la commande self.incrementer() . La syntaxe instance.methode(arguments) permet d'appeler une m\u00e9thode qui prend un ou plusieurs arguments en entr\u00e9e (autres que self ). M\u00e9thode synchroniser La fonction localtime du module time permet de conna\u00eetre l'heure locale au moment de l'appel de la fonction. L'objet renvoy\u00e9 poss\u00e8de (entre autres) trois attributs tm_hour , tm_min et tm_sec qui donnent respectivement l'heure, les minutes et les secondes de l'heure locale. On peut ajouter \u00e0 la d\u00e9finition de la classe Montre une m\u00e9thode synchroniser dont le r\u00f4le est de mettre la montre \u00e0 l'heure. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from time import localtime class Montre : def __init__ ( self , h , m , s ): \"\"\"M\u00e9thode constructeur initialisant les attributs aux valeurs h, m, s pass\u00e9es en argument.\"\"\" self . h = h self . m = m self . s = s def synchroniser ( self ): \"\"\"Synchronise la montre \u00e0 l'heure locale du moment de l'appel.\"\"\" heure_locale = localtime () self . h = heure_locale . tm_hour self . m = heure_locale . tm_min self . s = heure_locale . tm_sec Lorsque la m\u00e9thode synchroniser est appel\u00e9e pour une instance de la classe Montre , la valeur des attributs h , m et s est modifi\u00e9e pour cette instance. M\u00e9thode sp\u00e9ciale __str__ Si on souhaite afficher \u00e0 l'\u00e9cran l'heure de la montre, on peut se demander ce que donnerait l'instruction print(ma_montre) . L'affichage obtenu <__main__.Montre object at 0x7f45dc1f9350> n'est pas lisible, hormis la r\u00e9f\u00e9rence au fait que ma_montre est un objet de \"type\" Montre . Il est n\u00e9anmoins possible de faire appara\u00eetre un affichage personnalis\u00e9 beaucoup plus lisible de l'objet en d\u00e9finissant une m\u00e9thode sp\u00e9ciale nomm\u00e9e __str__ . 1 2 3 4 5 6 7 8 9 10 class Montre : def __init__ ( self , h , m , s ): \"\"\"M\u00e9thode constructeur initialisant les attributs aux valeurs h, m, s pass\u00e9es en argument.\"\"\" self . h = h self . m = m self . s = s def __str__ ( self ): \"\"\"Affiche l'heure de la montre au format HH:MM:SS.\"\"\" return f \" { self . h } : { self . m } : { self . s } \" La m\u00e9thode sp\u00e9ciale __str__ est cr\u00e9e pour \u00eatre appel\u00e9e par la fonction print . Elle doit donc renvoyer une cha\u00eene de caract\u00e8res.","title":"D\u00e9finition de m\u00e9thodes"},{"location":"prog_objet/#ce-quil-faut-savoir-et-savoir-faire","text":"Conna\u00eetre le vocabulaire de la programmation objet, en particulier la notion de classe, d'instance, d'attribut et de m\u00e9thode. Utiliser la notation point\u00e9e instance.attribut et instance.methode(arguments) . D\u00e9finir une classe, cr\u00e9er une instance et g\u00e9rer l'initialisation des attributs d'instance gr\u00e2ce \u00e0 la m\u00e9thode __init__ . D\u00e9finir une m\u00e9thode et comprendre l'utilisation du param\u00e8tre self .","title":"Ce qu'il faut savoir et savoir faire"},{"location":"prog_objet/#exercices-et-activites","text":"Exercices Compte bancaire Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Date Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Dominos (bient\u00f4t disponible) Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Labyrinthe (bient\u00f4t disponible) Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Activit\u00e9s Balle rebondissante L'objectif de l'activit\u00e9 est de faire rebondir une balle dans une fen\u00eatre graphique. Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici \u26a0\ufe0f Le fichier balle_pygame.py doit \u00eatre plac\u00e9 dans le m\u00eame r\u00e9pertoire que le carnet act_balle_rebondissante.ipynb . Corrig\u00e9 disponible ici Ensembles de Mandelbrot et de Julia L'objectif de l'activit\u00e9 est de repr\u00e9senter des fractales c\u00e9l\u00e8bres : l'ensemble de Mandelbrot et les ensembles de Julia. Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Fractions (bient\u00f4t disponible) Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Paquet de cartes (bient\u00f4t disponible) Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici","title":"Exercices et activit\u00e9s"},{"location":"rech_textuelle/","text":"Chapitre 11 : Recherche textuelle","title":"Recherche textuelle"},{"location":"rech_textuelle/#chapitre-11-recherche-textuelle","text":"","title":"Chapitre 11 : Recherche textuelle"},{"location":"recursivite/","text":"Chapitre 2 : R\u00e9cursivit\u00e9 Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Cahier \u00e0 t\u00e9l\u00e9charger ici Le but de ce chapitre est d'introduire le concept de fonction r\u00e9cursive . Notion de fonction r\u00e9cursive Il s'agit d'une fonction qui fait appel \u00e0 elle-m\u00eame lors de son ex\u00e9cution. Premier exemple : calcul de la somme des entiers compris entre a et b On suppose que a est inf\u00e9rieur \u00e0 b et on souhaite d\u00e9finir une fonction somme qui calcule la somme des entiers compris entre a et b . Fonction somme D\u00e9termine la somme des entiers compris entre a et b . Entr\u00e9es a : entier b : entier sup\u00e9rieur ou \u00e9gal \u00e0 a Sortie total : entier Impl\u00e9mentation Version it\u00e9rative Une premi\u00e8re fa\u00e7on de faire est d'utiliser une boucle pour : on obtient une version it\u00e9rative de la fonction. 1 2 3 4 5 def somme ( a , b ): total = 0 for k in range ( a , b + 1 ): total = total + k return total Version r\u00e9cursive Une autre fa\u00e7on de faire est de constater qu'il y a deux cas \u00e0 envisager : Si a == b , cela signifie qu'il y a un seul nombre dans la liste des nombres \u00e0 additionner : le nombre a . On renvoie donc sa valeur. Si a < b , on calcule r\u00e9cursivement la somme des entiers compris entre a+1 et b , on y ajoute la valeur de a et on renvoie le total. 1 2 3 4 5 6 def somme ( a , b ): if a == b : total = a else : total = a + somme ( a + 1 , b ) return total Ainsi d\u00e9finie, la fonction est une fonction r\u00e9cursive parce qu'elle s'appelle elle-m\u00eame dans le cas o\u00f9 a est diff\u00e9rent de b . On distingue deux parties dans l'\u00e9criture d'une fonction r\u00e9cursive : un ou plusieurs cas r\u00e9sursif(s) , dans lesquels la fonction fait appel \u00e0 elle-m\u00eame avec de nouveaux arguments, un ou plusieurs cas de base , qui permettent de mettre un terme aux appels r\u00e9cursifs successifs. Deuxi\u00e8me exemple : calcul du produit des entiers compris entre 1 et n On suppose que n est un entier strictement positif et on souhaite d\u00e9finir une fonction factorielle qui calcule le produit des entiers compris entre 1 et n . Fonction factorielle D\u00e9termine le produit des entiers compris entre 1 et n . Entr\u00e9e n : entier strictement positif Sortie fac : entier Impl\u00e9mentation Version it\u00e9rative 1 2 3 4 5 def factorielle ( n ): fac = 1 for k in range ( 2 , n + 1 ): fac = k * fac return fac Version r\u00e9cursive Pour l'\u00e9criture de la fonction r\u00e9cursive, deux cas \u00e0 sont envisager : Si n == 1 , cela signifie qu'il y a un seul nombre dans la liste des nombres \u00e0 multiplier : le nombre 1. On renvoie donc sa valeur. C'est le cas de base . Si n > 1 , on calcule r\u00e9cursivement le produit des entiers compris entre 1 et n-1 , on multiplie le r\u00e9sultat par la valeur de n et on renvoie le total. C'est le cas r\u00e9cursif . 1 2 3 4 5 6 def factorielle ( n ): if n == 0 : fac = 1 else : fac = n * factorielle ( n - 1 ) return fac Troisi\u00e8me exemple : calcul de x puissance n On suppose que x est un nombre et que n est un entier positif et on souhaite d\u00e9finir une fonction puissance qui calcule x puissance n . Fonction puissance D\u00e9termine la valeur de x puissance n . Entr\u00e9es x : entier ou flottant n : entier positif Sortie val : m\u00eame type que le param\u00e8tre d'entr\u00e9e x Impl\u00e9mentation Version it\u00e9rative 1 2 3 4 5 def puissance ( x , n ): val = 1 for k in range ( 1 , n + 1 ): val = x * val return val Version r\u00e9cursive Pour l'\u00e9criture de la fonction r\u00e9cursive, deux cas \u00e0 sont envisager : Si n == 0 , on utilise la propri\u00e9t\u00e9 \\(x^0 = 1\\) : on renvoie la valeur 1. C'est le cas de base . Si n > 0 , on utilise la propri\u00e9t\u00e9 \\(x^n = x \\times x^{n-1}\\) : on calcule r\u00e9cursivement \\(x^{n-1}\\) , on multiplie le r\u00e9sultat par la valeur de x et on renvoie le total. C'est le cas r\u00e9cursif . 1 2 3 4 5 def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 ) Pile d'appels r\u00e9cursifs Si on effectue l'appel puissance(2, 3) , on peut repr\u00e9senter la pile des quatre appels de la fonction puissance , et les param\u00e8tres correspondant \u00e0 chaque appel, sous la forme d'un arbre. 1 2 3 4 5 6 7 8 9 puissance ( 2 , 3 ) | return 2 * puissance ( 2 , 2 ) | return 2 * puissance ( 2 , 1 ) | return 2 * puissance ( 2 , 0 ) | return 1 Le nombre d'appels simultan\u00e9s de fonctions est limit\u00e9. On peut en conna\u00eetre le nombre maximal gr\u00e2ce \u00e0 la fonction getrecursionlimit du module sys . 1 2 from sys import getrecursionlimit print ( getrecursionlimit ()) Une erreur appara\u00eet si on essaie de r\u00e9aliser plus d'appels r\u00e9cursifs que la limite autoris\u00e9e. 1 RecursionError : maximum recursion depth exceeded in comparison La limite du nombre d'appels simultan\u00e9s de fonctions peut \u00eatre modifi\u00e9e gr\u00e2ce \u00e0 la fonction setrecursionlimit du module sys . 1 2 from sys import setrecursionlimit setrecursionlimit ( 4000 ) Il faut n\u00e9anmoins \u00eatre raisonnable en cas de modification de cette limite, car un nombre excessif de r\u00e9cursions provoque le plantage du programme \u00e0 cause d'une erreur de d\u00e9bordement de pile d'ex\u00e9cution ( stack overflow ). Tours de Hano\u00ef Les tours de Hano\u00ef sont un jeu de r\u00e9flexion consistant \u00e0 d\u00e9placer des disques de diam\u00e8tres diff\u00e9rents d'une tour gauche \u00e0 une tour droite en passant par une tour centrale, et ceci en un minimum de coups, tout en respectant les r\u00e8gles suivantes : on ne peut pas d\u00e9placer plus d'un disque \u00e0 la fois, on ne peut placer un disque que sur un autre disque plus grand ou sur un emplacement vide. Ce jeu est un exemple de probl\u00e8me qui peut \u00eatre r\u00e9solu par une approche r\u00e9cursive. Proc\u00e9dure solution_hanoi Affiche les mouvements \u00e0 effectuer pour r\u00e9soudre le probl\u00e8me des tours de Hano\u00ef \u00e0 n disques. Entr\u00e9es n : entier positif (nombre de disques) depart : cha\u00eene de caract\u00e8res (nom de la tour de d\u00e9part) intermediaire : cha\u00eene de caract\u00e8res (nom de la tour interm\u00e9diaire) arrivee : cha\u00eene de caract\u00e8res (nom de la tour d'arriv\u00e9e) Effet de bord : affichage de texte \u00e0 l'\u00e9cran Impl\u00e9mentation 1 2 3 4 5 def solution_hanoi ( n , depart , intermediaire , arrivee ): if n > 0 : solution_hanoi ( n - 1 , depart , arrivee , intermediaire ) print ( f \"D\u00e9placer un disque de { depart } vers { arrivee } .\" ) solution_hanoi ( n - 1 , intermediaire , depart , arrivee ) Le cas de base est celui o\u00f9 il n'y a aucun disque : on ne fait rien du tout. Pour d\u00e9placer n disques de la tour depart vers la tour arrivee , on proc\u00e8de en trois temps : on d\u00e9place r\u00e9cursivement n-1 disques de la tour depart vers la tour intermediaire , on d\u00e9place un disque (le plus grand) de la tour depart vers la tour arrivee , on d\u00e9place r\u00e9cursivement n-1 disques de la tour intermediaire vers la tour arrivee . L'appel hanoi(3, 'GAUCHE', 'CENTRE', 'DROITE') entra\u00eene les sept affichages suivants : 1 2 3 4 5 6 7 D\u00e9placer un disque de GAUCHE vers DROITE. D\u00e9placer un disque de GAUCHE vers CENTRE. D\u00e9placer un disque de DROITE vers CENTRE. D\u00e9placer un disque de GAUCHE vers DROITE. D\u00e9placer un disque de CENTRE vers GAUCHE. D\u00e9placer un disque de CENTRE vers DROITE. D\u00e9placer un disque de GAUCHE vers DROITE. Ce qu'il faut savoir et savoir faire \u00c9crire une fonction r\u00e9cursive, en identifiant le(s) cas de base et le(s) cas r\u00e9cursif(s). Dessiner un arbre d'appels r\u00e9cursifs. Exercices et activit\u00e9s Exercices Algorithme d'Euclide Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici D\u00e9composition d'un entier... Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Exponentiation rapide Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Palindromes Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Suite de Fibonacci Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Activit\u00e9s Cercles tangents L'objectif de l'activit\u00e9 d'\u00e9crire des proc\u00e9dures r\u00e9cursives pour dessiner des figures g\u00e9om\u00e9triques avec le module turtle . Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Fractales L'objectif de l'activit\u00e9 d'\u00e9crire des proc\u00e9dures r\u00e9cursives pour dessiner des figures fractales avec le module turtle . Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Le compte est bon ! L'objectif de l'activit\u00e9 est de cr\u00e9er un solveur du jeu Le compte est bon . Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici","title":"R\u00e9cursivit\u00e9"},{"location":"recursivite/#chapitre-2-recursivite","text":"Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Cahier \u00e0 t\u00e9l\u00e9charger ici Le but de ce chapitre est d'introduire le concept de fonction r\u00e9cursive .","title":"Chapitre 2 : R\u00e9cursivit\u00e9"},{"location":"recursivite/#notion-de-fonction-recursive","text":"Il s'agit d'une fonction qui fait appel \u00e0 elle-m\u00eame lors de son ex\u00e9cution.","title":"Notion de fonction r\u00e9cursive"},{"location":"recursivite/#premier-exemple-calcul-de-la-somme-des-entiers-compris-entre-a-et-b","text":"On suppose que a est inf\u00e9rieur \u00e0 b et on souhaite d\u00e9finir une fonction somme qui calcule la somme des entiers compris entre a et b . Fonction somme D\u00e9termine la somme des entiers compris entre a et b . Entr\u00e9es a : entier b : entier sup\u00e9rieur ou \u00e9gal \u00e0 a Sortie total : entier Impl\u00e9mentation Version it\u00e9rative Une premi\u00e8re fa\u00e7on de faire est d'utiliser une boucle pour : on obtient une version it\u00e9rative de la fonction. 1 2 3 4 5 def somme ( a , b ): total = 0 for k in range ( a , b + 1 ): total = total + k return total Version r\u00e9cursive Une autre fa\u00e7on de faire est de constater qu'il y a deux cas \u00e0 envisager : Si a == b , cela signifie qu'il y a un seul nombre dans la liste des nombres \u00e0 additionner : le nombre a . On renvoie donc sa valeur. Si a < b , on calcule r\u00e9cursivement la somme des entiers compris entre a+1 et b , on y ajoute la valeur de a et on renvoie le total. 1 2 3 4 5 6 def somme ( a , b ): if a == b : total = a else : total = a + somme ( a + 1 , b ) return total Ainsi d\u00e9finie, la fonction est une fonction r\u00e9cursive parce qu'elle s'appelle elle-m\u00eame dans le cas o\u00f9 a est diff\u00e9rent de b . On distingue deux parties dans l'\u00e9criture d'une fonction r\u00e9cursive : un ou plusieurs cas r\u00e9sursif(s) , dans lesquels la fonction fait appel \u00e0 elle-m\u00eame avec de nouveaux arguments, un ou plusieurs cas de base , qui permettent de mettre un terme aux appels r\u00e9cursifs successifs.","title":"Premier exemple : calcul de la somme des entiers compris entre a et b"},{"location":"recursivite/#deuxieme-exemple-calcul-du-produit-des-entiers-compris-entre-1-et-n","text":"On suppose que n est un entier strictement positif et on souhaite d\u00e9finir une fonction factorielle qui calcule le produit des entiers compris entre 1 et n . Fonction factorielle D\u00e9termine le produit des entiers compris entre 1 et n . Entr\u00e9e n : entier strictement positif Sortie fac : entier Impl\u00e9mentation Version it\u00e9rative 1 2 3 4 5 def factorielle ( n ): fac = 1 for k in range ( 2 , n + 1 ): fac = k * fac return fac Version r\u00e9cursive Pour l'\u00e9criture de la fonction r\u00e9cursive, deux cas \u00e0 sont envisager : Si n == 1 , cela signifie qu'il y a un seul nombre dans la liste des nombres \u00e0 multiplier : le nombre 1. On renvoie donc sa valeur. C'est le cas de base . Si n > 1 , on calcule r\u00e9cursivement le produit des entiers compris entre 1 et n-1 , on multiplie le r\u00e9sultat par la valeur de n et on renvoie le total. C'est le cas r\u00e9cursif . 1 2 3 4 5 6 def factorielle ( n ): if n == 0 : fac = 1 else : fac = n * factorielle ( n - 1 ) return fac","title":"Deuxi\u00e8me exemple : calcul du produit des entiers compris entre 1 et n"},{"location":"recursivite/#troisieme-exemple-calcul-de-x-puissance-n","text":"On suppose que x est un nombre et que n est un entier positif et on souhaite d\u00e9finir une fonction puissance qui calcule x puissance n . Fonction puissance D\u00e9termine la valeur de x puissance n . Entr\u00e9es x : entier ou flottant n : entier positif Sortie val : m\u00eame type que le param\u00e8tre d'entr\u00e9e x Impl\u00e9mentation Version it\u00e9rative 1 2 3 4 5 def puissance ( x , n ): val = 1 for k in range ( 1 , n + 1 ): val = x * val return val Version r\u00e9cursive Pour l'\u00e9criture de la fonction r\u00e9cursive, deux cas \u00e0 sont envisager : Si n == 0 , on utilise la propri\u00e9t\u00e9 \\(x^0 = 1\\) : on renvoie la valeur 1. C'est le cas de base . Si n > 0 , on utilise la propri\u00e9t\u00e9 \\(x^n = x \\times x^{n-1}\\) : on calcule r\u00e9cursivement \\(x^{n-1}\\) , on multiplie le r\u00e9sultat par la valeur de x et on renvoie le total. C'est le cas r\u00e9cursif . 1 2 3 4 5 def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 )","title":"Troisi\u00e8me exemple : calcul de x puissance n"},{"location":"recursivite/#pile-dappels-recursifs","text":"Si on effectue l'appel puissance(2, 3) , on peut repr\u00e9senter la pile des quatre appels de la fonction puissance , et les param\u00e8tres correspondant \u00e0 chaque appel, sous la forme d'un arbre. 1 2 3 4 5 6 7 8 9 puissance ( 2 , 3 ) | return 2 * puissance ( 2 , 2 ) | return 2 * puissance ( 2 , 1 ) | return 2 * puissance ( 2 , 0 ) | return 1 Le nombre d'appels simultan\u00e9s de fonctions est limit\u00e9. On peut en conna\u00eetre le nombre maximal gr\u00e2ce \u00e0 la fonction getrecursionlimit du module sys . 1 2 from sys import getrecursionlimit print ( getrecursionlimit ()) Une erreur appara\u00eet si on essaie de r\u00e9aliser plus d'appels r\u00e9cursifs que la limite autoris\u00e9e. 1 RecursionError : maximum recursion depth exceeded in comparison La limite du nombre d'appels simultan\u00e9s de fonctions peut \u00eatre modifi\u00e9e gr\u00e2ce \u00e0 la fonction setrecursionlimit du module sys . 1 2 from sys import setrecursionlimit setrecursionlimit ( 4000 ) Il faut n\u00e9anmoins \u00eatre raisonnable en cas de modification de cette limite, car un nombre excessif de r\u00e9cursions provoque le plantage du programme \u00e0 cause d'une erreur de d\u00e9bordement de pile d'ex\u00e9cution ( stack overflow ).","title":"Pile d'appels r\u00e9cursifs"},{"location":"recursivite/#tours-de-hanoi","text":"Les tours de Hano\u00ef sont un jeu de r\u00e9flexion consistant \u00e0 d\u00e9placer des disques de diam\u00e8tres diff\u00e9rents d'une tour gauche \u00e0 une tour droite en passant par une tour centrale, et ceci en un minimum de coups, tout en respectant les r\u00e8gles suivantes : on ne peut pas d\u00e9placer plus d'un disque \u00e0 la fois, on ne peut placer un disque que sur un autre disque plus grand ou sur un emplacement vide. Ce jeu est un exemple de probl\u00e8me qui peut \u00eatre r\u00e9solu par une approche r\u00e9cursive. Proc\u00e9dure solution_hanoi Affiche les mouvements \u00e0 effectuer pour r\u00e9soudre le probl\u00e8me des tours de Hano\u00ef \u00e0 n disques. Entr\u00e9es n : entier positif (nombre de disques) depart : cha\u00eene de caract\u00e8res (nom de la tour de d\u00e9part) intermediaire : cha\u00eene de caract\u00e8res (nom de la tour interm\u00e9diaire) arrivee : cha\u00eene de caract\u00e8res (nom de la tour d'arriv\u00e9e) Effet de bord : affichage de texte \u00e0 l'\u00e9cran Impl\u00e9mentation 1 2 3 4 5 def solution_hanoi ( n , depart , intermediaire , arrivee ): if n > 0 : solution_hanoi ( n - 1 , depart , arrivee , intermediaire ) print ( f \"D\u00e9placer un disque de { depart } vers { arrivee } .\" ) solution_hanoi ( n - 1 , intermediaire , depart , arrivee ) Le cas de base est celui o\u00f9 il n'y a aucun disque : on ne fait rien du tout. Pour d\u00e9placer n disques de la tour depart vers la tour arrivee , on proc\u00e8de en trois temps : on d\u00e9place r\u00e9cursivement n-1 disques de la tour depart vers la tour intermediaire , on d\u00e9place un disque (le plus grand) de la tour depart vers la tour arrivee , on d\u00e9place r\u00e9cursivement n-1 disques de la tour intermediaire vers la tour arrivee . L'appel hanoi(3, 'GAUCHE', 'CENTRE', 'DROITE') entra\u00eene les sept affichages suivants : 1 2 3 4 5 6 7 D\u00e9placer un disque de GAUCHE vers DROITE. D\u00e9placer un disque de GAUCHE vers CENTRE. D\u00e9placer un disque de DROITE vers CENTRE. D\u00e9placer un disque de GAUCHE vers DROITE. D\u00e9placer un disque de CENTRE vers GAUCHE. D\u00e9placer un disque de CENTRE vers DROITE. D\u00e9placer un disque de GAUCHE vers DROITE.","title":"Tours de Hano\u00ef"},{"location":"recursivite/#ce-quil-faut-savoir-et-savoir-faire","text":"\u00c9crire une fonction r\u00e9cursive, en identifiant le(s) cas de base et le(s) cas r\u00e9cursif(s). Dessiner un arbre d'appels r\u00e9cursifs.","title":"Ce qu'il faut savoir et savoir faire"},{"location":"recursivite/#exercices-et-activites","text":"Exercices Algorithme d'Euclide Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici D\u00e9composition d'un entier... Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Exponentiation rapide Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Palindromes Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Suite de Fibonacci Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Activit\u00e9s Cercles tangents L'objectif de l'activit\u00e9 d'\u00e9crire des proc\u00e9dures r\u00e9cursives pour dessiner des figures g\u00e9om\u00e9triques avec le module turtle . Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Fractales L'objectif de l'activit\u00e9 d'\u00e9crire des proc\u00e9dures r\u00e9cursives pour dessiner des figures fractales avec le module turtle . Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Le compte est bon ! L'objectif de l'activit\u00e9 est de cr\u00e9er un solveur du jeu Le compte est bon . Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici","title":"Exercices et activit\u00e9s"}]}