{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cours de Terminale NSI Programme du cours Interfaces de programmation d'applications R\u00e9cursivit\u00e9 Programmation objet Modularit\u00e9 Listes cha\u00een\u00e9es Mise au point de programmes M\u00e9thode diviser pour r\u00e9gner Piles et files Arbres Arbres binaires de recherche Recherche textuelle Graphes Graphes pond\u00e9r\u00e9s Calculabilit\u00e9 et d\u00e9cidabilit\u00e9 Sujets et corrig\u00e9s des devoirs Devoirs maison Immeubles al\u00e9atoires Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici S\u00e9ismes Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Devoirs surveill\u00e9s 1 Sujet de la premi\u00e8re partie \u00e0 t\u00e9l\u00e9charger ici Sujet de la seconde partie \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici \u00c9preuves pratiques 01 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 02 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 16 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 17 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 18 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 19 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 20 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 23 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 26 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 29 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Logiciels \u00e0 installer Installation d'Anaconda La suite Anaconda , t\u00e9l\u00e9chargeable ici , contient l'\u00e9diteur de carnets Jupyter et l'\u00e9diteur de code Spyder .","title":"Accueil"},{"location":"#cours-de-terminale-nsi","text":"","title":"Cours de Terminale NSI"},{"location":"#programme-du-cours","text":"Interfaces de programmation d'applications R\u00e9cursivit\u00e9 Programmation objet Modularit\u00e9 Listes cha\u00een\u00e9es Mise au point de programmes M\u00e9thode diviser pour r\u00e9gner Piles et files Arbres Arbres binaires de recherche Recherche textuelle Graphes Graphes pond\u00e9r\u00e9s Calculabilit\u00e9 et d\u00e9cidabilit\u00e9","title":"Programme du cours"},{"location":"#sujets-et-corriges-des-devoirs","text":"Devoirs maison Immeubles al\u00e9atoires Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici S\u00e9ismes Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Devoirs surveill\u00e9s 1 Sujet de la premi\u00e8re partie \u00e0 t\u00e9l\u00e9charger ici Sujet de la seconde partie \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici \u00c9preuves pratiques 01 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 02 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 16 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 17 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 18 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 19 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 20 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 23 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 26 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici 29 Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici","title":"Sujets et corrig\u00e9s des devoirs"},{"location":"#logiciels-a-installer","text":"Installation d'Anaconda La suite Anaconda , t\u00e9l\u00e9chargeable ici , contient l'\u00e9diteur de carnets Jupyter et l'\u00e9diteur de code Spyder .","title":"Logiciels \u00e0 installer"},{"location":"abr/","text":"Chapitre 10 : Arbres binaires de recherche","title":"Arbres binaires de recherche"},{"location":"abr/#chapitre-10-arbres-binaires-de-recherche","text":"","title":"Chapitre 10 : Arbres binaires de recherche"},{"location":"api/","text":"Chapitre 1 : Interfaces de programmation d'applications Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Cahier \u00e0 t\u00e9l\u00e9charger ici Une API ( Application Programming Interface ), ou une interface de programmation d\u2019applications , est un ensemble de classes, fonctions, constantes gr\u00e2ce auquel un programme fournisseur met \u00e0 disposition diverses fonctionnalit\u00e9s pour des programmes consommateurs . C'est le programme fournisseur qui d\u00e9finit de quelle fa\u00e7on les fonctionnalit\u00e9s sont mises \u00e0 disposition des consommateurs, en imposant \u00e9ventuellement un certain nombre de contraintes d'acc\u00e8s \u00e0 l'API. On s'int\u00e9resse ici \u00e0 la Base Adresse Nationale qui est une API gratuite du gouvernement fran\u00e7ais permettant d'obtenir un certain nombre d'informations \u00e0 partir d'une adresse postale. Interrogation de l'API On souhaite, gr\u00e2ce \u00e0 l'API, obtenir des informations sur l'adresse postale du lyc\u00e9e Louis Armand. Pour interroger l'API, il suffit d'envoyer une requ\u00eate GET \u00e0 l'URL https://api-adresse.data.gouv.fr/search/?q=173-boulevard-de-strasbourg&postcode=94130 . On remarque que l'adresse postale sur laquelle on souhaite interroger l'API est indiqu\u00e9e dans l'URL. La r\u00e9ponse renvoy\u00e9e par l'API est la suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { \"type\" : \"FeatureCollection\" , \"version\" : \"draft\" , \"features\" : [{ \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.491306 , 48.846716 ]}, \"properties\" : { \"label\" : \"173 Boulevard de Strasbourg 94130 Nogent-sur-Marne\" , \"score\" : 0.88381 , \"housenumber\" : \"173\" , \"id\" : \"94052_8560_00173\" , \"name\" : \"173 Boulevard de Strasbourg\" , \"postcode\" : \"94130\" , \"citycode\" : \"94052\" , \"x\" : 662668.4 , \"y\" : 6860861.49 , \"city\" : \"Nogent-sur-Marne\" , \"context\" : \"94, Val-de-Marne, \u00cele-de-France\" , \"type\" : \"housenumber\" , \"importance\" : 0.72191 , \"street\" : \"Boulevard de Strasbourg\" }}], \"attribution\" : \"BAN\" , \"licence\" : \"ETALAB-2.0\" , \"query\" : \"173-boulevard-de-strasbourg\" , \"filters\" : { \"postcode\" : \"94130\" }, \"limit\" : 5 } La r\u00e9ponse re\u00e7ue est au format JSON ( JavaScript Object Notation ). La signification des champs de la r\u00e9ponse est donn\u00e9e dans la documentation de l'API. L'interrogation de l'API peut \u00eatre r\u00e9alis\u00e9e gr\u00e2ce au code Python ci-dessous. Lors de son ex\u00e9cution, la r\u00e9ponse renvoy\u00e9e par l'API est stock\u00e9e dans la variable reponse . Impl\u00e9mentation 1 2 3 4 import requests url = \"https://api-adresse.data.gouv.fr/search/?q=173-boulevard-de-strasbourg&postcode=94130\" reponse = requests . get ( url ) reponse = reponse . json () La fonction get du module requests permet d'envoyer une requ\u00eate GET \u00e0 l'URL sp\u00e9cifi\u00e9e et ensuite de r\u00e9cup\u00e9rer la r\u00e9ponse. La commande reponse.json() extrait de la r\u00e9ponse les donn\u00e9es encod\u00e9es dans le format JSON, qui est un format de donn\u00e9es textuelles que l'on peut traiter comme s'il s'agissait d'un dictionnaire Python. Traitement de la r\u00e9ponse renvoy\u00e9e par l'API Il est possible de d\u00e9finir une fonction qui interroge l'API \u00e0 partir d'une adresse postale au choix, pass\u00e9e en param\u00e8tre. Premi\u00e8re version : donn\u00e9es compl\u00e8tes Fonction interroger_API_BAN Interroge l'API Base Adresse Nationale . Entr\u00e9es adresse : cha\u00eene de caract\u00e8res code_postal : entier ou cha\u00eene de caract\u00e8res Sortie reponse : dictionnaire contenant l'ensemble des donn\u00e9es renvoy\u00e9es par l'API Penser \u00e0 importer le module requests ! Impl\u00e9mentation 1 2 3 4 5 def interroger_API_BAN ( adresse , code_postal ): url = f \"https://api-adresse.data.gouv.fr/search/?q= { adresse } &postcode= { code_postal } \" reponse = requests . get ( url ) reponse = reponse . json () return reponse L'utilisation d'une f-string pour l'\u00e9criture de l'URL permet d'y int\u00e9grer simplement et lisiblement les param\u00e8tres d'entr\u00e9e de la fonction. Ici, la fonction renvoie l'ensemble des donn\u00e9es r\u00e9cup\u00e9r\u00e9es via l'API. La plupart du temps, on souhaite n\u00e9anmoins isoler les donn\u00e9es qui nous int\u00e9ressent et elles seules. Seconde version : donn\u00e9es s\u00e9lectionn\u00e9es Fonction interroger_API_BAN Renvoie les coordonn\u00e9es g\u00e9ographiques d'un lieu apr\u00e8s interrogation de l'API Base Adresse Nationale . Entr\u00e9es adresse : cha\u00eene de caract\u00e8res code_postal : entier ou cha\u00eene de caract\u00e8res Sortie (lat, long) : couple de coordonn\u00e9es g\u00e9ographiques Penser \u00e0 importer le module requests ! Impl\u00e9mentation 1 2 3 4 5 6 7 8 def interroger_API_BAN ( adresse , code_postal ): url = f \"https://api-adresse.data.gouv.fr/search/?q= { adresse } &postcode= { code_postal } \" reponse = requests . get ( url ) reponse = reponse . json () coord = reponse [ 'features' ][ 0 ][ 'geometry' ][ 'coordinates' ] long = coord [ 0 ] lat = coord [ 1 ] return ( lat , long ) Une fois la r\u00e9ponse de l'API transform\u00e9e en dictionnaire, il suffit de naviguer pour r\u00e9cup\u00e9rer les donn\u00e9es qui nous int\u00e9ressent, comme par exemple les coordonn\u00e9es g\u00e9ographiques de l'adresse pass\u00e9e en param\u00e8tre. reponse est un dictionnaire poss\u00e9dant huit cl\u00e9s : 'type' , 'version' , 'features' , 'attribution' , 'licence' , 'query' , 'filters' et 'limit' . reponse['features'] est un tableau contenant un ou plusieurs \u00e9l\u00e9ments de type dictionnaire : chaque dictionnaire correspond \u00e0 une adresse potentielle, la premi\u00e8re (indice 0 ) \u00e9tant la plus susceptible de correspondre \u00e0 notre demande. reponse['features'][0] est un dictionnaire poss\u00e9dant trois cl\u00e9s : 'type' , 'geometry' et 'properties' . reponse['features'][0]['geometry'] est un dictionnaire poss\u00e9dant deux cl\u00e9s : 'type' et 'coordinates' . reponse['features'][0]['geometry']['coordinates'] est un tableau contenant deux \u00e9l\u00e9ments de type flottant : la longitude (indice 0 ) et la latitude (indice 1 ) du lieu. Ce qu'il faut savoir et savoir faire Envoyer une requ\u00eate \u00e0 une API avec le module requests . S\u00e9lectionner des informations dans la r\u00e9ponse renvoy\u00e9e par une API. Consulter la documentation d'une API. Exercices et activit\u00e9s Exercices Ast\u00e9ro\u00efdes \u00e0 surveiller Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Bulletin m\u00e9t\u00e9o Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Composition des produits alimentaires Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici D\u00e9coupage administratif Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Activit\u00e9s Carte de vigilance m\u00e9t\u00e9orologique L'objectif de l'activit\u00e9 est d'utiliser une API pour r\u00e9aliser une carte de vigilance m\u00e9t\u00e9orologique. Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici \u26a0\ufe0f Le fichier carte_france.py doit \u00eatre plac\u00e9 dans le m\u00eame r\u00e9pertoire que le carnet act_vigilance_meteo.ipynb . Corrig\u00e9 disponible ici Centres de vaccination anti-Covid L'objectif de l'activit\u00e9 est d'utiliser une API pour cartographier les centres de vaccination anti-Covid d'un d\u00e9partement. Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Station spatiale internationale L'objectif de l'activit\u00e9 est d'utiliser une API pour suivre les d\u00e9placements de la station spatiale internationale. Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici","title":"Interfaces de programmation d'applications"},{"location":"api/#chapitre-1-interfaces-de-programmation-dapplications","text":"Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Cahier \u00e0 t\u00e9l\u00e9charger ici Une API ( Application Programming Interface ), ou une interface de programmation d\u2019applications , est un ensemble de classes, fonctions, constantes gr\u00e2ce auquel un programme fournisseur met \u00e0 disposition diverses fonctionnalit\u00e9s pour des programmes consommateurs . C'est le programme fournisseur qui d\u00e9finit de quelle fa\u00e7on les fonctionnalit\u00e9s sont mises \u00e0 disposition des consommateurs, en imposant \u00e9ventuellement un certain nombre de contraintes d'acc\u00e8s \u00e0 l'API. On s'int\u00e9resse ici \u00e0 la Base Adresse Nationale qui est une API gratuite du gouvernement fran\u00e7ais permettant d'obtenir un certain nombre d'informations \u00e0 partir d'une adresse postale.","title":"Chapitre 1 : Interfaces de programmation d'applications"},{"location":"api/#interrogation-de-lapi","text":"On souhaite, gr\u00e2ce \u00e0 l'API, obtenir des informations sur l'adresse postale du lyc\u00e9e Louis Armand. Pour interroger l'API, il suffit d'envoyer une requ\u00eate GET \u00e0 l'URL https://api-adresse.data.gouv.fr/search/?q=173-boulevard-de-strasbourg&postcode=94130 . On remarque que l'adresse postale sur laquelle on souhaite interroger l'API est indiqu\u00e9e dans l'URL. La r\u00e9ponse renvoy\u00e9e par l'API est la suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { \"type\" : \"FeatureCollection\" , \"version\" : \"draft\" , \"features\" : [{ \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.491306 , 48.846716 ]}, \"properties\" : { \"label\" : \"173 Boulevard de Strasbourg 94130 Nogent-sur-Marne\" , \"score\" : 0.88381 , \"housenumber\" : \"173\" , \"id\" : \"94052_8560_00173\" , \"name\" : \"173 Boulevard de Strasbourg\" , \"postcode\" : \"94130\" , \"citycode\" : \"94052\" , \"x\" : 662668.4 , \"y\" : 6860861.49 , \"city\" : \"Nogent-sur-Marne\" , \"context\" : \"94, Val-de-Marne, \u00cele-de-France\" , \"type\" : \"housenumber\" , \"importance\" : 0.72191 , \"street\" : \"Boulevard de Strasbourg\" }}], \"attribution\" : \"BAN\" , \"licence\" : \"ETALAB-2.0\" , \"query\" : \"173-boulevard-de-strasbourg\" , \"filters\" : { \"postcode\" : \"94130\" }, \"limit\" : 5 } La r\u00e9ponse re\u00e7ue est au format JSON ( JavaScript Object Notation ). La signification des champs de la r\u00e9ponse est donn\u00e9e dans la documentation de l'API. L'interrogation de l'API peut \u00eatre r\u00e9alis\u00e9e gr\u00e2ce au code Python ci-dessous. Lors de son ex\u00e9cution, la r\u00e9ponse renvoy\u00e9e par l'API est stock\u00e9e dans la variable reponse . Impl\u00e9mentation 1 2 3 4 import requests url = \"https://api-adresse.data.gouv.fr/search/?q=173-boulevard-de-strasbourg&postcode=94130\" reponse = requests . get ( url ) reponse = reponse . json () La fonction get du module requests permet d'envoyer une requ\u00eate GET \u00e0 l'URL sp\u00e9cifi\u00e9e et ensuite de r\u00e9cup\u00e9rer la r\u00e9ponse. La commande reponse.json() extrait de la r\u00e9ponse les donn\u00e9es encod\u00e9es dans le format JSON, qui est un format de donn\u00e9es textuelles que l'on peut traiter comme s'il s'agissait d'un dictionnaire Python.","title":"Interrogation de l'API"},{"location":"api/#traitement-de-la-reponse-renvoyee-par-lapi","text":"Il est possible de d\u00e9finir une fonction qui interroge l'API \u00e0 partir d'une adresse postale au choix, pass\u00e9e en param\u00e8tre. Premi\u00e8re version : donn\u00e9es compl\u00e8tes Fonction interroger_API_BAN Interroge l'API Base Adresse Nationale . Entr\u00e9es adresse : cha\u00eene de caract\u00e8res code_postal : entier ou cha\u00eene de caract\u00e8res Sortie reponse : dictionnaire contenant l'ensemble des donn\u00e9es renvoy\u00e9es par l'API Penser \u00e0 importer le module requests ! Impl\u00e9mentation 1 2 3 4 5 def interroger_API_BAN ( adresse , code_postal ): url = f \"https://api-adresse.data.gouv.fr/search/?q= { adresse } &postcode= { code_postal } \" reponse = requests . get ( url ) reponse = reponse . json () return reponse L'utilisation d'une f-string pour l'\u00e9criture de l'URL permet d'y int\u00e9grer simplement et lisiblement les param\u00e8tres d'entr\u00e9e de la fonction. Ici, la fonction renvoie l'ensemble des donn\u00e9es r\u00e9cup\u00e9r\u00e9es via l'API. La plupart du temps, on souhaite n\u00e9anmoins isoler les donn\u00e9es qui nous int\u00e9ressent et elles seules. Seconde version : donn\u00e9es s\u00e9lectionn\u00e9es Fonction interroger_API_BAN Renvoie les coordonn\u00e9es g\u00e9ographiques d'un lieu apr\u00e8s interrogation de l'API Base Adresse Nationale . Entr\u00e9es adresse : cha\u00eene de caract\u00e8res code_postal : entier ou cha\u00eene de caract\u00e8res Sortie (lat, long) : couple de coordonn\u00e9es g\u00e9ographiques Penser \u00e0 importer le module requests ! Impl\u00e9mentation 1 2 3 4 5 6 7 8 def interroger_API_BAN ( adresse , code_postal ): url = f \"https://api-adresse.data.gouv.fr/search/?q= { adresse } &postcode= { code_postal } \" reponse = requests . get ( url ) reponse = reponse . json () coord = reponse [ 'features' ][ 0 ][ 'geometry' ][ 'coordinates' ] long = coord [ 0 ] lat = coord [ 1 ] return ( lat , long ) Une fois la r\u00e9ponse de l'API transform\u00e9e en dictionnaire, il suffit de naviguer pour r\u00e9cup\u00e9rer les donn\u00e9es qui nous int\u00e9ressent, comme par exemple les coordonn\u00e9es g\u00e9ographiques de l'adresse pass\u00e9e en param\u00e8tre. reponse est un dictionnaire poss\u00e9dant huit cl\u00e9s : 'type' , 'version' , 'features' , 'attribution' , 'licence' , 'query' , 'filters' et 'limit' . reponse['features'] est un tableau contenant un ou plusieurs \u00e9l\u00e9ments de type dictionnaire : chaque dictionnaire correspond \u00e0 une adresse potentielle, la premi\u00e8re (indice 0 ) \u00e9tant la plus susceptible de correspondre \u00e0 notre demande. reponse['features'][0] est un dictionnaire poss\u00e9dant trois cl\u00e9s : 'type' , 'geometry' et 'properties' . reponse['features'][0]['geometry'] est un dictionnaire poss\u00e9dant deux cl\u00e9s : 'type' et 'coordinates' . reponse['features'][0]['geometry']['coordinates'] est un tableau contenant deux \u00e9l\u00e9ments de type flottant : la longitude (indice 0 ) et la latitude (indice 1 ) du lieu.","title":"Traitement de la r\u00e9ponse renvoy\u00e9e par l'API"},{"location":"api/#ce-quil-faut-savoir-et-savoir-faire","text":"Envoyer une requ\u00eate \u00e0 une API avec le module requests . S\u00e9lectionner des informations dans la r\u00e9ponse renvoy\u00e9e par une API. Consulter la documentation d'une API.","title":"Ce qu'il faut savoir et savoir faire"},{"location":"api/#exercices-et-activites","text":"Exercices Ast\u00e9ro\u00efdes \u00e0 surveiller Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Bulletin m\u00e9t\u00e9o Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Composition des produits alimentaires Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici D\u00e9coupage administratif Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Activit\u00e9s Carte de vigilance m\u00e9t\u00e9orologique L'objectif de l'activit\u00e9 est d'utiliser une API pour r\u00e9aliser une carte de vigilance m\u00e9t\u00e9orologique. Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici \u26a0\ufe0f Le fichier carte_france.py doit \u00eatre plac\u00e9 dans le m\u00eame r\u00e9pertoire que le carnet act_vigilance_meteo.ipynb . Corrig\u00e9 disponible ici Centres de vaccination anti-Covid L'objectif de l'activit\u00e9 est d'utiliser une API pour cartographier les centres de vaccination anti-Covid d'un d\u00e9partement. Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Station spatiale internationale L'objectif de l'activit\u00e9 est d'utiliser une API pour suivre les d\u00e9placements de la station spatiale internationale. Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici","title":"Exercices et activit\u00e9s"},{"location":"arbres/","text":"Chapitre 9 : Arbres","title":"Arbres"},{"location":"arbres/#chapitre-9-arbres","text":"","title":"Chapitre 9 : Arbres"},{"location":"calculabilite/","text":"Chapitre 14 : Calculabilit\u00e9 et d\u00e9cidabilit\u00e9","title":"Calculabilit\u00e9 et d\u00e9cidabilit\u00e9"},{"location":"calculabilite/#chapitre-14-calculabilite-et-decidabilite","text":"","title":"Chapitre 14 : Calculabilit\u00e9 et d\u00e9cidabilit\u00e9"},{"location":"diviser/","text":"Chapitre 7 : M\u00e9thode diviser pour r\u00e9gner","title":"M\u00e9thode diviser pour r\u00e9gner"},{"location":"diviser/#chapitre-7-methode-diviser-pour-regner","text":"","title":"Chapitre 7 : M\u00e9thode diviser pour r\u00e9gner"},{"location":"exemple/","text":"Titre Sous titre Document joint Exercice Exercice suppl\u00e9mentaire Activit\u00e9 Bla bla bla bla bla... Solution R\u00e9ponses au probl\u00e8me.... A retenir Sur le cahier Erreur Important !","title":"Titre"},{"location":"exemple/#titre","text":"","title":"Titre"},{"location":"exemple/#sous-titre","text":"Document joint Exercice Exercice suppl\u00e9mentaire Activit\u00e9 Bla bla bla bla bla... Solution R\u00e9ponses au probl\u00e8me.... A retenir Sur le cahier Erreur Important !","title":"Sous titre"},{"location":"graphes/","text":"Chapitre 12 : Graphes","title":"Graphes"},{"location":"graphes/#chapitre-12-graphes","text":"","title":"Chapitre 12 : Graphes"},{"location":"graphes_pond/","text":"Chapitre 13 : Graphes pond\u00e9r\u00e9s","title":"Graphes pond\u00e9r\u00e9s"},{"location":"graphes_pond/#chapitre-13-graphes-ponderes","text":"","title":"Chapitre 13 : Graphes pond\u00e9r\u00e9s"},{"location":"listes/","text":"Chapitre 5 : Listes cha\u00een\u00e9es","title":"Listes cha\u00een\u00e9es"},{"location":"listes/#chapitre-5-listes-chainees","text":"","title":"Chapitre 5 : Listes cha\u00een\u00e9es"},{"location":"mise_au_point/","text":"Chapitre 6 : Mise au point de programmes","title":"Mise au point de programmes"},{"location":"mise_au_point/#chapitre-6-mise-au-point-de-programmes","text":"","title":"Chapitre 6 : Mise au point de programmes"},{"location":"modularite/","text":"Chapitre 4 : Modularit\u00e9","title":"Modularit\u00e9"},{"location":"modularite/#chapitre-4-modularite","text":"","title":"Chapitre 4 : Modularit\u00e9"},{"location":"patience/","text":"Un peu de patience !","title":"Programmation objet"},{"location":"patience/#un-peu-de-patience","text":"","title":"Un peu de patience !"},{"location":"piles_files/","text":"Chapitre 8 : Piles et files","title":"Piles et files"},{"location":"piles_files/#chapitre-8-piles-et-files","text":"","title":"Chapitre 8 : Piles et files"},{"location":"prog_objet/","text":"Chapitre 3 : Programmation objet","title":"Chapitre 3 : Programmation objet"},{"location":"prog_objet/#chapitre-3-programmation-objet","text":"","title":"Chapitre 3 : Programmation objet"},{"location":"rech_textuelle/","text":"Chapitre 11 : Recherche textuelle","title":"Recherche textuelle"},{"location":"rech_textuelle/#chapitre-11-recherche-textuelle","text":"","title":"Chapitre 11 : Recherche textuelle"},{"location":"recursivite/","text":"Chapitre 2 : R\u00e9cursivit\u00e9 Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Cahier \u00e0 t\u00e9l\u00e9charger ici Le but de ce chapitre est d'introduire le concept de fonction r\u00e9cursive . Notion de fonction r\u00e9cursive Il s'agit d'une fonction qui fait appel \u00e0 elle-m\u00eame lors de son ex\u00e9cution. Premier exemple : calcul de la somme des entiers compris entre a et b On suppose que a est inf\u00e9rieur \u00e0 b et on souhaite d\u00e9finir une fonction somme qui calcule la somme des entiers compris entre a et b . Fonction somme D\u00e9termine la somme des entiers compris entre a et b . Entr\u00e9es a : entier b : entier sup\u00e9rieur ou \u00e9gal \u00e0 a Sortie total : entier Impl\u00e9mentation Version it\u00e9rative Une premi\u00e8re fa\u00e7on de faire est d'utiliser une boucle pour : on obtient une version it\u00e9rative de la fonction. 1 2 3 4 5 def somme ( a , b ): total = 0 for k in range ( a , b + 1 ): total = total + k return total Version r\u00e9cursive Une autre fa\u00e7on de faire est de constater qu'il y a deux cas \u00e0 envisager : Si a == b , cela signifie qu'il y a un seul nombre dans la liste des nombres \u00e0 additionner : le nombre a . On renvoie donc sa valeur. Si a < b , on calcule r\u00e9cursivement la somme des entiers compris entre a+1 et b , on y ajoute la valeur de a et on renvoie le total. 1 2 3 4 5 6 def somme ( a , b ): if a == b : total = a else : total = a + somme ( a + 1 , b ) return total Ainsi d\u00e9finie, la fonction est une fonction r\u00e9cursive parce qu'elle s'appelle elle-m\u00eame dans le cas o\u00f9 a est diff\u00e9rent de b . On distingue deux parties dans l'\u00e9criture d'une fonction r\u00e9cursive : un ou plusieurs cas r\u00e9sursif(s) , dans lesquels la fonction fait appel \u00e0 elle-m\u00eame avec de nouveaux arguments, un ou plusieurs cas de base , qui permettent de mettre un terme aux appels r\u00e9cursifs successifs. Deuxi\u00e8me exemple : calcul du produit des entiers compris entre 1 et n On suppose que n est un entier strictement positif et on souhaite d\u00e9finir une fonction factorielle qui calcule le produit des entiers compris entre 1 et n . Fonction factorielle D\u00e9termine le produit des entiers compris entre 1 et n . Entr\u00e9e n : entier strictement positif Sortie fac : entier Impl\u00e9mentation Version it\u00e9rative 1 2 3 4 5 def factorielle ( n ): fac = 1 for k in range ( 2 , n + 1 ): fac = k * fac return fac Version r\u00e9cursive Pour l'\u00e9criture de la fonction r\u00e9cursive, deux cas \u00e0 sont envisager : Si n == 1 , cela signifie qu'il y a un seul nombre dans la liste des nombres \u00e0 multiplier : le nombre 1. On renvoie donc sa valeur. C'est le cas de base . Si n > 1 , on calcule r\u00e9cursivement le produit des entiers compris entre 1 et n-1 , on multiplie le r\u00e9sultat par la valeur de n et on renvoie le total. C'est le cas r\u00e9cursif . 1 2 3 4 5 6 def factorielle ( n ): if n == 0 : fac = 1 else : fac = n * factorielle ( n - 1 ) return fac Troisi\u00e8me exemple : calcul de x puissance n On suppose que x est un nombre et que n est un entier positif et on souhaite d\u00e9finir une fonction puissance qui calcule x puissance n . Fonction puissance D\u00e9termine la valeur de x puissance n . Entr\u00e9es x : entier ou flottant n : entier positif Sortie val : m\u00eame type que le param\u00e8tre d'entr\u00e9e x Impl\u00e9mentation Version it\u00e9rative 1 2 3 4 5 def puissance ( x , n ): val = 1 for k in range ( 1 , n + 1 ): val = x * val return val Version r\u00e9cursive Pour l'\u00e9criture de la fonction r\u00e9cursive, deux cas \u00e0 sont envisager : Si n == 0 , on utilise la propri\u00e9t\u00e9 \\(x^0 = 1\\) : on renvoie la valeur 1. C'est le cas de base . Si n > 0 , on utilise la propri\u00e9t\u00e9 \\(x^n = x \\times x^{n-1}\\) : on calcule r\u00e9cursivement \\(x^{n-1}\\) , on multiplie le r\u00e9sultat par la valeur de x et on renvoie le total. C'est le cas r\u00e9cursif . 1 2 3 4 5 def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 ) Pile d'appels r\u00e9cursifs Si on effectue l'appel puissance(2, 3) , on peut repr\u00e9senter la pile des quatre appels de la fonction puissance , et les param\u00e8tres correspondant \u00e0 chaque appel, sous la forme d'un arbre. 1 2 3 4 5 6 7 8 9 puissance ( 2 , 3 ) | return 2 * puissance ( 2 , 2 ) | return 2 * puissance ( 2 , 1 ) | return 2 * puissance ( 2 , 0 ) | return 1 Le nombre d'appels simultan\u00e9s de fonctions est limit\u00e9. On peut en conna\u00eetre le nombre maximal gr\u00e2ce \u00e0 la fonction getrecursionlimit du module sys . 1 2 from sys import getrecursionlimit print ( getrecursionlimit ()) Une erreur appara\u00eet si on essaie de r\u00e9aliser plus d'appels r\u00e9cursifs que la limite autoris\u00e9e. 1 RecursionError : maximum recursion depth exceeded in comparison La limite du nombre d'appels simultan\u00e9s de fonctions peut \u00eatre modifi\u00e9e gr\u00e2ce \u00e0 la fonction setrecursionlimit du module sys . 1 2 from sys import setrecursionlimit setrecursionlimit ( 4000 ) Il faut n\u00e9anmoins \u00eatre raisonnable en cas de modification de cette limite, car un nombre excessif de r\u00e9cursions provoque le plantage du programme \u00e0 cause d'une erreur de d\u00e9bordement de pile d'ex\u00e9cution ( stack overflow ). Tours de Hano\u00ef Les tours de Hano\u00ef sont un jeu de r\u00e9flexion consistant \u00e0 d\u00e9placer des disques de diam\u00e8tres diff\u00e9rents d'une tour gauche \u00e0 une tour droite en passant par une tour centrale, et ceci en un minimum de coups, tout en respectant les r\u00e8gles suivantes : on ne peut pas d\u00e9placer plus d'un disque \u00e0 la fois, on ne peut placer un disque que sur un autre disque plus grand ou sur un emplacement vide. Ce jeu est un exemple de probl\u00e8me qui peut \u00eatre r\u00e9solu par une approche r\u00e9cursive. Proc\u00e9dure solution_hanoi Affiche les mouvements \u00e0 effectuer pour r\u00e9soudre le probl\u00e8me des tours de Hano\u00ef \u00e0 n disques. Entr\u00e9es n : entier positif (nombre de disques) depart : cha\u00eene de caract\u00e8res (nom de la tour de d\u00e9part) intermediaire : cha\u00eene de caract\u00e8res (nom de la tour interm\u00e9diaire) arrivee : cha\u00eene de caract\u00e8res (nom de la tour d'arriv\u00e9e) Effet de bord : affichage de texte \u00e0 l'\u00e9cran Impl\u00e9mentation 1 2 3 4 5 def solution_hanoi ( n , depart , intermediaire , arrivee ): if n > 0 : solution_hanoi ( n - 1 , depart , arrivee , intermediaire ) print ( f \"D\u00e9placer un disque de { depart } vers { arrivee } .\" ) solution_hanoi ( n - 1 , intermediaire , depart , arrivee ) Le cas de base est celui o\u00f9 il n'y a aucun disque : on ne fait rien du tout. Pour d\u00e9placer n disques de la tour depart vers la tour arrivee , on proc\u00e8de en trois temps : on d\u00e9place r\u00e9cursivement n-1 disques de la tour depart vers la tour intermediaire , on d\u00e9place un disque (le plus grand) de la tour depart vers la tour arrivee , on d\u00e9place r\u00e9cursivement n-1 disques de la tour intermediaire vers la tour arrivee . L'appel hanoi(3, 'GAUCHE', 'CENTRE', 'DROITE') entra\u00eene les sept affichages suivants : 1 2 3 4 5 6 7 D\u00e9placer un disque de GAUCHE vers DROITE. D\u00e9placer un disque de GAUCHE vers CENTRE. D\u00e9placer un disque de DROITE vers CENTRE. D\u00e9placer un disque de GAUCHE vers DROITE. D\u00e9placer un disque de CENTRE vers GAUCHE. D\u00e9placer un disque de CENTRE vers DROITE. D\u00e9placer un disque de GAUCHE vers DROITE. Ce qu'il faut savoir et savoir faire \u00c9crire une fonction r\u00e9cursive, en identifiant le(s) cas de base et le(s) cas r\u00e9cursif(s). Dessiner un arbre d'appels r\u00e9cursifs. Exercices et activit\u00e9s Exercices Algorithme d'Euclide Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici D\u00e9composition d'un entier... Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Exponentiation rapide Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Palindromes Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Suite de Fibonacci Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Activit\u00e9s Cercles tangents L'objectif de l'activit\u00e9 d'\u00e9crire des proc\u00e9dures r\u00e9cursives pour dessiner des figures g\u00e9om\u00e9triques avec le module turtle . Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Fractales L'objectif de l'activit\u00e9 d'\u00e9crire des proc\u00e9dures r\u00e9cursives pour dessiner des figures fractales avec le module turtle . Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Le compte est bon ! L'objectif de l'activit\u00e9 est de cr\u00e9er un solveur du jeu Le compte est bon . Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici","title":"R\u00e9cursivit\u00e9"},{"location":"recursivite/#chapitre-2-recursivite","text":"Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Cahier \u00e0 t\u00e9l\u00e9charger ici Le but de ce chapitre est d'introduire le concept de fonction r\u00e9cursive .","title":"Chapitre 2 : R\u00e9cursivit\u00e9"},{"location":"recursivite/#notion-de-fonction-recursive","text":"Il s'agit d'une fonction qui fait appel \u00e0 elle-m\u00eame lors de son ex\u00e9cution.","title":"Notion de fonction r\u00e9cursive"},{"location":"recursivite/#premier-exemple-calcul-de-la-somme-des-entiers-compris-entre-a-et-b","text":"On suppose que a est inf\u00e9rieur \u00e0 b et on souhaite d\u00e9finir une fonction somme qui calcule la somme des entiers compris entre a et b . Fonction somme D\u00e9termine la somme des entiers compris entre a et b . Entr\u00e9es a : entier b : entier sup\u00e9rieur ou \u00e9gal \u00e0 a Sortie total : entier Impl\u00e9mentation Version it\u00e9rative Une premi\u00e8re fa\u00e7on de faire est d'utiliser une boucle pour : on obtient une version it\u00e9rative de la fonction. 1 2 3 4 5 def somme ( a , b ): total = 0 for k in range ( a , b + 1 ): total = total + k return total Version r\u00e9cursive Une autre fa\u00e7on de faire est de constater qu'il y a deux cas \u00e0 envisager : Si a == b , cela signifie qu'il y a un seul nombre dans la liste des nombres \u00e0 additionner : le nombre a . On renvoie donc sa valeur. Si a < b , on calcule r\u00e9cursivement la somme des entiers compris entre a+1 et b , on y ajoute la valeur de a et on renvoie le total. 1 2 3 4 5 6 def somme ( a , b ): if a == b : total = a else : total = a + somme ( a + 1 , b ) return total Ainsi d\u00e9finie, la fonction est une fonction r\u00e9cursive parce qu'elle s'appelle elle-m\u00eame dans le cas o\u00f9 a est diff\u00e9rent de b . On distingue deux parties dans l'\u00e9criture d'une fonction r\u00e9cursive : un ou plusieurs cas r\u00e9sursif(s) , dans lesquels la fonction fait appel \u00e0 elle-m\u00eame avec de nouveaux arguments, un ou plusieurs cas de base , qui permettent de mettre un terme aux appels r\u00e9cursifs successifs.","title":"Premier exemple : calcul de la somme des entiers compris entre a et b"},{"location":"recursivite/#deuxieme-exemple-calcul-du-produit-des-entiers-compris-entre-1-et-n","text":"On suppose que n est un entier strictement positif et on souhaite d\u00e9finir une fonction factorielle qui calcule le produit des entiers compris entre 1 et n . Fonction factorielle D\u00e9termine le produit des entiers compris entre 1 et n . Entr\u00e9e n : entier strictement positif Sortie fac : entier Impl\u00e9mentation Version it\u00e9rative 1 2 3 4 5 def factorielle ( n ): fac = 1 for k in range ( 2 , n + 1 ): fac = k * fac return fac Version r\u00e9cursive Pour l'\u00e9criture de la fonction r\u00e9cursive, deux cas \u00e0 sont envisager : Si n == 1 , cela signifie qu'il y a un seul nombre dans la liste des nombres \u00e0 multiplier : le nombre 1. On renvoie donc sa valeur. C'est le cas de base . Si n > 1 , on calcule r\u00e9cursivement le produit des entiers compris entre 1 et n-1 , on multiplie le r\u00e9sultat par la valeur de n et on renvoie le total. C'est le cas r\u00e9cursif . 1 2 3 4 5 6 def factorielle ( n ): if n == 0 : fac = 1 else : fac = n * factorielle ( n - 1 ) return fac","title":"Deuxi\u00e8me exemple : calcul du produit des entiers compris entre 1 et n"},{"location":"recursivite/#troisieme-exemple-calcul-de-x-puissance-n","text":"On suppose que x est un nombre et que n est un entier positif et on souhaite d\u00e9finir une fonction puissance qui calcule x puissance n . Fonction puissance D\u00e9termine la valeur de x puissance n . Entr\u00e9es x : entier ou flottant n : entier positif Sortie val : m\u00eame type que le param\u00e8tre d'entr\u00e9e x Impl\u00e9mentation Version it\u00e9rative 1 2 3 4 5 def puissance ( x , n ): val = 1 for k in range ( 1 , n + 1 ): val = x * val return val Version r\u00e9cursive Pour l'\u00e9criture de la fonction r\u00e9cursive, deux cas \u00e0 sont envisager : Si n == 0 , on utilise la propri\u00e9t\u00e9 \\(x^0 = 1\\) : on renvoie la valeur 1. C'est le cas de base . Si n > 0 , on utilise la propri\u00e9t\u00e9 \\(x^n = x \\times x^{n-1}\\) : on calcule r\u00e9cursivement \\(x^{n-1}\\) , on multiplie le r\u00e9sultat par la valeur de x et on renvoie le total. C'est le cas r\u00e9cursif . 1 2 3 4 5 def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 )","title":"Troisi\u00e8me exemple : calcul de x puissance n"},{"location":"recursivite/#pile-dappels-recursifs","text":"Si on effectue l'appel puissance(2, 3) , on peut repr\u00e9senter la pile des quatre appels de la fonction puissance , et les param\u00e8tres correspondant \u00e0 chaque appel, sous la forme d'un arbre. 1 2 3 4 5 6 7 8 9 puissance ( 2 , 3 ) | return 2 * puissance ( 2 , 2 ) | return 2 * puissance ( 2 , 1 ) | return 2 * puissance ( 2 , 0 ) | return 1 Le nombre d'appels simultan\u00e9s de fonctions est limit\u00e9. On peut en conna\u00eetre le nombre maximal gr\u00e2ce \u00e0 la fonction getrecursionlimit du module sys . 1 2 from sys import getrecursionlimit print ( getrecursionlimit ()) Une erreur appara\u00eet si on essaie de r\u00e9aliser plus d'appels r\u00e9cursifs que la limite autoris\u00e9e. 1 RecursionError : maximum recursion depth exceeded in comparison La limite du nombre d'appels simultan\u00e9s de fonctions peut \u00eatre modifi\u00e9e gr\u00e2ce \u00e0 la fonction setrecursionlimit du module sys . 1 2 from sys import setrecursionlimit setrecursionlimit ( 4000 ) Il faut n\u00e9anmoins \u00eatre raisonnable en cas de modification de cette limite, car un nombre excessif de r\u00e9cursions provoque le plantage du programme \u00e0 cause d'une erreur de d\u00e9bordement de pile d'ex\u00e9cution ( stack overflow ).","title":"Pile d'appels r\u00e9cursifs"},{"location":"recursivite/#tours-de-hanoi","text":"Les tours de Hano\u00ef sont un jeu de r\u00e9flexion consistant \u00e0 d\u00e9placer des disques de diam\u00e8tres diff\u00e9rents d'une tour gauche \u00e0 une tour droite en passant par une tour centrale, et ceci en un minimum de coups, tout en respectant les r\u00e8gles suivantes : on ne peut pas d\u00e9placer plus d'un disque \u00e0 la fois, on ne peut placer un disque que sur un autre disque plus grand ou sur un emplacement vide. Ce jeu est un exemple de probl\u00e8me qui peut \u00eatre r\u00e9solu par une approche r\u00e9cursive. Proc\u00e9dure solution_hanoi Affiche les mouvements \u00e0 effectuer pour r\u00e9soudre le probl\u00e8me des tours de Hano\u00ef \u00e0 n disques. Entr\u00e9es n : entier positif (nombre de disques) depart : cha\u00eene de caract\u00e8res (nom de la tour de d\u00e9part) intermediaire : cha\u00eene de caract\u00e8res (nom de la tour interm\u00e9diaire) arrivee : cha\u00eene de caract\u00e8res (nom de la tour d'arriv\u00e9e) Effet de bord : affichage de texte \u00e0 l'\u00e9cran Impl\u00e9mentation 1 2 3 4 5 def solution_hanoi ( n , depart , intermediaire , arrivee ): if n > 0 : solution_hanoi ( n - 1 , depart , arrivee , intermediaire ) print ( f \"D\u00e9placer un disque de { depart } vers { arrivee } .\" ) solution_hanoi ( n - 1 , intermediaire , depart , arrivee ) Le cas de base est celui o\u00f9 il n'y a aucun disque : on ne fait rien du tout. Pour d\u00e9placer n disques de la tour depart vers la tour arrivee , on proc\u00e8de en trois temps : on d\u00e9place r\u00e9cursivement n-1 disques de la tour depart vers la tour intermediaire , on d\u00e9place un disque (le plus grand) de la tour depart vers la tour arrivee , on d\u00e9place r\u00e9cursivement n-1 disques de la tour intermediaire vers la tour arrivee . L'appel hanoi(3, 'GAUCHE', 'CENTRE', 'DROITE') entra\u00eene les sept affichages suivants : 1 2 3 4 5 6 7 D\u00e9placer un disque de GAUCHE vers DROITE. D\u00e9placer un disque de GAUCHE vers CENTRE. D\u00e9placer un disque de DROITE vers CENTRE. D\u00e9placer un disque de GAUCHE vers DROITE. D\u00e9placer un disque de CENTRE vers GAUCHE. D\u00e9placer un disque de CENTRE vers DROITE. D\u00e9placer un disque de GAUCHE vers DROITE.","title":"Tours de Hano\u00ef"},{"location":"recursivite/#ce-quil-faut-savoir-et-savoir-faire","text":"\u00c9crire une fonction r\u00e9cursive, en identifiant le(s) cas de base et le(s) cas r\u00e9cursif(s). Dessiner un arbre d'appels r\u00e9cursifs.","title":"Ce qu'il faut savoir et savoir faire"},{"location":"recursivite/#exercices-et-activites","text":"Exercices Algorithme d'Euclide Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici D\u00e9composition d'un entier... Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Exponentiation rapide Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Palindromes Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Suite de Fibonacci Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 disponible ici Activit\u00e9s Cercles tangents L'objectif de l'activit\u00e9 d'\u00e9crire des proc\u00e9dures r\u00e9cursives pour dessiner des figures g\u00e9om\u00e9triques avec le module turtle . Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Fractales L'objectif de l'activit\u00e9 d'\u00e9crire des proc\u00e9dures r\u00e9cursives pour dessiner des figures fractales avec le module turtle . Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici Le compte est bon ! L'objectif de l'activit\u00e9 est de cr\u00e9er un solveur du jeu Le compte est bon . Carnet Jupyter \u00e0 travailler sur le site CAPYTALE ou \u00e0 t\u00e9l\u00e9charger ici Corrig\u00e9 bient\u00f4t disponible ici","title":"Exercices et activit\u00e9s"}]}